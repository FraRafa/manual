{
  "hash": "31e2e5cd65ae86e3e2f4a62f6b07d90f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Cap√≠tulo 8 ‚Äî Python avanzado: condicionales, bucles, funciones y SymPy\"\n---\n\n[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/08-python-avanzado-condicionales-bucles-funciones-sympy.ipynb){.btn .btn-success target=\"_blank\"}\n\n\n::: {.callout-note}\n## Objetivos del cap√≠tulo\n\n- Usar **condicionales** (`if/elif/else`) para tomar decisiones sin ‚Äúromper‚Äù el programa.\n- Escribir **bucles** (`for` y `while`) con acumuladores y contadores, sin errores de l√≥gica.\n- Crear **funciones** reutilizables con validaci√≥n de argumentos.\n- (Opcional) Usar **SymPy** para resolver ecuaciones y graficar funciones impl√≠citas sin depender de ‚Äúc√°lculo manual‚Äù.\n:::\n\n::: {.column-margin}\n<details>\n<summary><strong>Glosario</strong></summary>\n\n- **condicional**: bloque que se ejecuta si se cumple una condici√≥n (`if`).\n- **bucle**: repite un bloque de c√≥digo (ej. `for`, `while`).\n- **acumulador**: variable que ‚Äúsuma‚Äù/‚Äújunta‚Äù resultados dentro de un bucle.\n- **√≠ndice**: posici√≥n dentro de una secuencia (0, 1, 2, ...).\n- **return**: salida de una funci√≥n (lo que la funci√≥n ‚Äúdevuelve‚Äù).\n- **argumento**: valor que le pasas a una funci√≥n (ej. `raizp(9)`).\n- **SymPy**: librer√≠a para matem√°ticas simb√≥licas (resolver/derivar/ecuaciones).\n- **funci√≥n impl√≠cita**: ecuaci√≥n del tipo `F(x, y) = 0` (no despejada).\n</details>\n:::\n\n---\n\n## 1. Condicionales y bucles (patrones que vas a usar siempre)\n\n### 1.1 Bucle + condicional (ejemplo b√°sico)\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Ejemplo b√°sico de un bucle y un condicional\ni = 1\nfor x in [1, 7, 20, 12, 9, 17]:\n    if x % 2 == 0:\n        print(i, x, \"es par\")\n    else:\n        print(i, x, \"es impar\")\n    i += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 1 es impar\n2 7 es impar\n3 20 es par\n4 12 es par\n5 9 es impar\n6 17 es impar\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis (en simple)\n\n- `for x in [...]`: recorre elementos de una lista (uno por uno).\n- `if x % 2 == 0`: condici√≥n (aqu√≠: ‚Äú¬øx es divisible para 2?‚Äù).\n- `i += 1`: abreviaci√≥n de `i = i + 1` (incrementa el contador).\n:::\n\n::: {.callout-warning}\n### Error com√∫n\nOlvidar `i += 1` deja el contador ‚Äúcongelado‚Äù y el resultado se repite mal.\n:::\n\n---\n\n### 1.2 Bucle con secuencia no num√©rica y acumulador\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Ejemplo de bucle con secuencia no num√©rica y variable que se acumula\nlista = [\"Econom√≠a\", \"Estad√≠stica\", \"Python\", \"Datos\"]\n\nacum = \"\"\nfor palabra in lista:\n    acum = acum + palabra + \" | \"\n\nacum\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'Econom√≠a | Estad√≠stica | Python | Datos | '\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Para qu√© sirve esto\nUn acumulador es √∫til cuando:\n- construyes texto,\n- construyes una lista de resultados,\n- sumas valores (ej. suma total, promedio, etc.).\n:::\n\n::: {.callout-tip}\n### Tip\nPara textos muy largos, a veces es mejor acumular en lista y al final usar `\"\".join(...)`.\nAqu√≠ lo hacemos simple a prop√≥sito.\n:::\n\n---\n\n### 1.3 √çndices en un `for` (cuando necesitas posici√≥n)\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Ejemplo de bucle donde el contador se usa como √≠ndice\nx = [10, 2, 7, 15]\ny = [0] * len(x)  # crea una lista de ceros del mismo tama√±o\n\nfor i in range(len(x)):\n    y[i] = x[i] ** 2\n\nx, y\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n([10, 2, 7, 15], [100, 4, 49, 225])\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave\n\n- `range(len(x))` produce 0, 1, 2, ..., `len(x)-1`.\n- `y = [0] * len(x)` reserva espacio para escribir resultados.\n- `x[i]` es ‚Äúel elemento i-√©simo‚Äù (ojo: Python empieza en 0).\n:::\n\n::: {.callout-warning}\n### Error com√∫n\nConfundir √≠ndices: el primer elemento es `x[0]`, no `x[1]`.\n:::\n\n---\n\n### 1.4 El mismo ejemplo usando `while`\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Ejemplo anterior usando \"while\"\nx = [10, 2, 7, 15]\ny = [0] * len(x)\n\ni = 0\nwhile i < len(x):\n    y[i] = x[i] ** 2\n    i += 1\n\nx, y\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n([10, 2, 7, 15], [100, 4, 49, 225])\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Cu√°ndo usar `while`\n√ösalo cuando no sabes cu√°ntas repeticiones necesitas de antemano,\ny la condici√≥n ‚Äúde parada‚Äù depende de lo que ocurre dentro del bucle.\n:::\n\n::: {.callout-warning}\n### Error com√∫n (grave)\nUn `while` sin `i += 1` (o sin actualizar la condici√≥n) puede volverse un **bucle infinito**.\n:::\n\n---\n\n## 2. Funciones (para no copiar/pegar c√≥digo)\n\nUna funci√≥n te permite empaquetar un procedimiento y reutilizarlo:\n\n- Recibe **argumentos**\n- Hace un proceso\n- Devuelve un resultado con `return`\n\n### 2.1 Ejemplo: ra√≠z cuadrada solo para positivos\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Definimos funci√≥n que obtiene la ra√≠z cuadrada pero solo de n√∫meros positivos\ndef raizp(x):\n    if x < 0:\n        return None\n    return np.sqrt(x)\n\nraizp(9), raizp(-9)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n(np.float64(3.0), None)\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave\n\n- `def nombre(parametro):` define una funci√≥n.\n- `return ...` devuelve un resultado y termina la funci√≥n.\n- `return None` es una forma simple de decir ‚Äúno hay resultado v√°lido‚Äù.\n:::\n\n::: {.callout-tip}\n### Tip de calidad\nEn proyectos reales, muchas veces conviene lanzar un error con `raise ValueError(...)`.\nAqu√≠ usamos `None` para mantenerlo amigable para principiantes.\n:::\n\n---\n\n### 2.2 Funci√≥n l√≥gica: ¬øes potencia de 3?\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Definimos funci√≥n para saber si un n√∫mero n es potencia de 3\ndef es_potencia_de_3(n):\n    if n < 1:\n        return False\n    while n % 3 == 0:\n        n = n // 3  # divisi√≥n entera\n    return n == 1\n\nfor k in [1, 3, 9, 12, 27, 28, 81]:\n    print(k, es_potencia_de_3(k))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 True\n3 True\n9 True\n12 False\n27 True\n28 False\n81 True\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave\n\n- `n // 3` divide y se queda con la parte entera.\n- `while n % 3 == 0` sigue mientras ‚Äúsea divisible por 3‚Äù.\n- al final preguntamos si qued√≥ `n == 1`.\n:::\n\n---\n\n### 2.3 Funci√≥n aplicada: fractal tipo ‚Äútapete‚Äù (Sierpi≈Ñski) (visual)\n\n> En este ejemplo, **n debe ser potencia de 3**.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Definimos funci√≥n para crear un fractal (tapete de Sierpi≈Ñski) (n debe ser potencia de 3)\ndef ej_fractal(n):\n    if not es_potencia_de_3(n):\n        raise ValueError(\"n debe ser potencia de 3 (ej. 3, 9, 27, 81, ...)\")\n\n    A = np.ones((n, n), dtype=int)\n    step = n\n\n    while step > 1:\n        step = step // 3\n        for i in range(0, n, step * 3):\n            for j in range(0, n, step * 3):\n                A[i + step:i + 2 * step, j + step:j + 2 * step] = 0\n\n    plt.imshow(A, cmap=\"gray_r\")\n    plt.axis(\"off\")\n    plt.title(f\"Fractal (n={n})\")\n    plt.show()\n    plt.close()\n\nej_fractal(27)\n```\n\n::: {.cell-output .cell-output-display}\n![](08-python-avanzado-condicionales-bucles-funciones-sympy_files/figure-pdf/cell-9-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-tip}\n### Tips y errores comunes\n\n- Si usas un `n` que no sea potencia de 3, este ejemplo **debe fallar**: eso es intencional (validaci√≥n).\n- Si tu entorno no muestra la figura, revisa que est√©s ejecutando en un notebook (Colab/Jupyter) o en Quarto con ejecuci√≥n habilitada.\n:::\n\n---\n\n## 3. SymPy (opcional): ecuaciones, derivadas y gr√°ficas impl√≠citas\n\nSi SymPy no est√° disponible, el manual no se rompe: simplemente no ejecutamos esta parte.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nif sp is None:\n    print(\"SymPy no est√° instalado en este entorno. En Colab puedes instalar con: !pip -q install sympy\")\n```\n:::\n\n\n### 3.1 Expresiones simb√≥licas y graficar una funci√≥n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nif sp is not None:\n    # Importamos m√≥dulo SymPy (Symbolic Python: biblioteca para matem√°ticas simb√≥licas)\n    x = sp.Symbol(\"x\")\n\n    # Ejemplo: par√°bola\n    f = x**2 - 4*x + 3\n\n    # Graficar con SymPy (r√°pido)\n    sp.plot(f, (x, -2, 6), title=\"f(x) = x^2 - 4x + 3\", show=True)\n```\n\n::: {.cell-output .cell-output-display}\n![](08-python-avanzado-condicionales-bucles-funciones-sympy_files/figure-pdf/cell-11-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (SymPy)\n\n- `sp.Symbol(\"x\")` crea una variable simb√≥lica.\n- `f = ...` crea una expresi√≥n simb√≥lica.\n- `sp.plot(...)` grafica en un rango.\n:::\n\n---\n\n### 3.2 Resolver un sistema de ecuaciones (dos ecuaciones)\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nif sp is not None:\n    x, y = sp.symbols(\"x y\")\n\n    eq1 = sp.Eq(x + y, 10)\n    eq2 = sp.Eq(2*x - y, 3)\n\n    sol = sp.solve([eq1, eq2], [x, y], dict=True)\n    sol\n```\n:::\n\n\n::: {.callout-tip}\n### Tip\n`dict=True` te devuelve la soluci√≥n como diccionario, m√°s c√≥modo para leer y reemplazar.\n:::\n\n---\n\n### 3.3 Graficar funciones impl√≠citas (una o varias)\n\nA veces tienes ecuaciones del tipo:\n\n- `F(x, y) = 0`\n\ny quieres graficar su curva.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nif sp is not None:\n    x, y = sp.symbols(\"x y\")\n\n    # Funci√≥n para graficar varias funciones impl√≠citas\n    def plot_implicitas(ecuaciones, xlim=(-5, 5), ylim=(-5, 5), titulo=\"Funciones impl√≠citas\"):\n        p = sp.plot_implicit(ecuaciones[0], (x, xlim[0], xlim[1]), (y, ylim[0], ylim[1]),\n                             show=False)\n        for eq in ecuaciones[1:]:\n            p2 = sp.plot_implicit(eq, (x, xlim[0], xlim[1]), (y, ylim[0], ylim[1]),\n                                  show=False)\n            for s in p2:\n                p.append(s)\n        p.title = titulo\n        p.show()\n\n    # Planeando y resolviendo un sistema de dos ecuaciones (y graficando)\n    eq1 = sp.Eq(x + y - 2, 0)\n    eq2 = sp.Eq(x**2 + y**2 - 4, 0)\n\n    plot_implicitas([eq1, eq2], xlim=(-3, 3), ylim=(-3, 3), titulo=\"Intersecci√≥n de dos curvas\")\n```\n\n::: {.cell-output .cell-output-display}\n![](08-python-avanzado-condicionales-bucles-funciones-sympy_files/figure-pdf/cell-13-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-warning}\n### Error com√∫n\nEn `plot_implicit` las ecuaciones deben quedar como igualdad a cero (o con `Eq(..., 0)`).\nSi no, SymPy a veces interpreta mal lo que quieres graficar.\n:::\n\n---\n\n## Ejercicios propuestos\n\n1) **Par o impar (bucle + condicional)**  \n   Crea una lista con 10 n√∫meros enteros y escribe un bucle que imprima si cada uno es par o impar.\n\n   **Respuesta esperada:** 10 l√≠neas, cada una con ‚Äúpar‚Äù o ‚Äúimpar‚Äù.\n\n2) **Acumulador de texto**  \n   Dada una lista de palabras, construye un string final separado por comas.\n\n   **Respuesta esperada:** un string tipo `\"a, b, c, d\"`.\n\n3) **Cuadrados con √≠ndice**  \n   Dada una lista `x`, crea `y` con los cuadrados, pero esta vez usando un `while`.\n\n   **Respuesta esperada:** `y[i] == x[i]**2` para todo i.\n\n4) **Funci√≥n de validaci√≥n**  \n   Escribe una funci√≥n `solo_positivos(x)` que devuelva `x` si `x>0` y `None` si no.\n\n   **Respuesta esperada:** `solo_positivos(3)=3` y `solo_positivos(-1)=None`.\n\n5) **Potencia de 3**  \n   Prueba tu funci√≥n `es_potencia_de_3` con los valores 1, 2, 3, 9, 18, 27.\n\n   **Respuesta esperada:** `True` solo para 1, 3, 9, 27.\n\n6) *(Opcional)* **SymPy: sistema**  \n   Resuelve un sistema 2x2 distinto al del ejemplo y muestra la soluci√≥n.\n\n   **Respuesta esperada:** una soluci√≥n `{x: ..., y: ...}`.\n\n---\n\n::: {.content-visible when-format=\"pdf\"}\n## Glosario (para Colab)\n\n- **if/elif/else**: decisiones por condici√≥n.\n- **for / while**: bucles para repetici√≥n.\n- **acumulador**: variable que agrega resultados.\n- **√≠ndice**: posici√≥n en una lista/array (empieza en 0).\n- **return**: salida de una funci√≥n.\n- **SymPy**: librer√≠a simb√≥lica (resolver/derivar/graficar).\n:::\n\n",
    "supporting": [
      "08-python-avanzado-condicionales-bucles-funciones-sympy_files\\figure-pdf"
    ],
    "filters": []
  }
}