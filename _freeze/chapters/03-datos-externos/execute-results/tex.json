{
  "hash": "a86faa71494c2057dd05a0a14fb7513a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Cap√≠tulo 3 ‚Äî Datos externos (leer y guardar archivos con pandas)\"\n---\n\n[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/03-datos-externos.ipynb){.btn .btn-success target=\"_blank\"}\n\n\n::: {.callout-note}\n## Objetivos del cap√≠tulo\n\nAl terminar este cap√≠tulo vas a poder:\n\n- leer datos desde archivos comunes (`.txt`, `.csv`, `.xlsx`) usando `pandas`,\n- entender los par√°metros m√°s importantes de lectura: `sep`, `header`, `names`,\n- guardar tus datos desde Python (`to_csv`, `to_excel`) de forma reproducible,\n- distinguir claramente lo **local** (sin internet) de lo **online** (opcional, depende de conexi√≥n).\n:::\n\n---\n\n## 1. La idea general: ‚Äúarchivo ‚Üí DataFrame‚Äù\n\nEn la pr√°ctica, casi todo flujo de datos es:\n\n1) **leer** un archivo en un `DataFrame`  \n2) **transformar** (limpiar, filtrar, crear variables)  \n3) **guardar** el resultado\n\n::: {.column-margin}\n<details>\n<summary><strong>Glosario</strong></summary>\n\n- **DataFrame**: tabla de datos en `pandas` (filas y columnas).\n- **CSV**: archivo de texto con valores separados por comas.\n- **delimiter / sep**: separador entre columnas (coma, espacio, tab, etc.).\n- **header**: indica si el archivo tiene fila de nombres.\n- **ruta (path)**: ubicaci√≥n del archivo (ej. `Datos/mi_archivo.csv`).\n- **relativa**: ruta desde tu carpeta del proyecto.\n- **absoluta**: ruta completa del disco (m√°s fr√°gil).\n</details>\n:::\n\n---\n\n## 2. Leer archivos de texto (`.txt`) y CSV (`.csv`)\n\nVamos a usar ejemplos **locales** (sin internet). Para simular un archivo, usaremos `StringIO` (un ‚Äúarchivo en memoria‚Äù).\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nfrom io import StringIO\n```\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (leer archivos)\n\n- `pd.read_table(...)` se usa para texto con separador (por ejemplo espacios o tabulaciones).\n- `pd.read_csv(...)` se usa para CSV (separado por comas).\n- En ambos, el separador se controla con `sep=` (o `delimiter=`).\n:::\n\n---\n\n### 2.1 Texto con separador por espacios\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ntexto = '''year product1 product2 product3\n2010  3        1        2\n2011  4        2        2\n2012  6        3        1\n'''\n\ndf_txt = pd.read_table(StringIO(texto), sep=r\"\\s+\")\ndf_txt\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>product1</th>\n      <th>product2</th>\n      <th>product3</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2010</td>\n      <td>3</td>\n      <td>1</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2011</td>\n      <td>4</td>\n      <td>2</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2012</td>\n      <td>6</td>\n      <td>3</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n**Qu√© significa `sep=r\"\\s+\"`**  \n- `\\s+` es ‚Äúuno o m√°s espacios‚Äù (sirve si hay varios espacios entre columnas).\n\n---\n\n### 2.2 CSV simple\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ncsv = '''year,product1,product2,product3\n2010,3,1,2\n2011,4,2,2\n2012,6,3,1\n'''\n\ndf_csv = pd.read_csv(StringIO(csv))\ndf_csv\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>product1</th>\n      <th>product2</th>\n      <th>product3</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2010</td>\n      <td>3</td>\n      <td>1</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2011</td>\n      <td>4</td>\n      <td>2</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2012</td>\n      <td>6</td>\n      <td>3</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n---\n\n### 2.3 Cuando el archivo NO tiene encabezados\n\nA veces un archivo viene sin nombres de columnas. En ese caso:\n\n- `header=None` para decir ‚Äúno hay encabezado‚Äù\n- `names=[...]` para asignar nombres\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ncsv_sin_header = '''2010,3,1,2\n2011,4,2,2\n2012,6,3,1\n'''\n\ndf_csv2 = pd.read_csv(\n    StringIO(csv_sin_header),\n    header=None,\n    names=[\"year\", \"product1\", \"product2\", \"product3\"]\n)\ndf_csv2\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>year</th>\n      <th>product1</th>\n      <th>product2</th>\n      <th>product3</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2010</td>\n      <td>3</td>\n      <td>1</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2011</td>\n      <td>4</td>\n      <td>2</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2012</td>\n      <td>6</td>\n      <td>3</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n---\n\n## 3. Guardar datos (exportar)\n\nGuardar es importante por 2 razones:\n\n- para no perder trabajo,\n\n- para poder compartir resultados.\n\n::: {.callout-note}\n### Sintaxis clave (guardar)\n\n- `df.to_csv(\"archivo.csv\", index=False)` guarda CSV.\n- `df.to_excel(\"archivo.xlsx\", index=False)` guarda Excel.\n- `index=False` evita guardar la columna de √≠ndice como una columna extra.\n:::\n\n---\n\n### 3.1 Guardar CSV (ejemplo)\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndf_csv2.to_csv(\"salida_ejemplo.csv\", index=False)\n```\n:::\n\n\n> En el manual (Quarto) no lo ejecutamos para no crear archivos en el render.  \n> En VSCode o Colab s√≠ puedes ejecutarlo sin problema.\n\n---\n\n### 3.2 Guardar Excel (ejemplo)\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndf_csv2.to_excel(\"salida_ejemplo.xlsx\", index=False)\n```\n:::\n\n\n---\n\n## 4. Leer Excel (`.xlsx`) sin depender de internet\n\nPara practicar la sintaxis sin archivos externos, vamos a:\n\n1) crear un `DataFrame`,\n2) guardarlo a un Excel en memoria,\n3) volverlo a leer con `read_excel`.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfrom io import BytesIO\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndf_base = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [10, 20, 30]})\nbuffer = BytesIO()\n\nwith pd.ExcelWriter(buffer, engine=\"openpyxl\") as writer:\n    df_base.to_excel(writer, sheet_name=\"Hoja1\", index=False)\n\nbuffer.seek(0)\n\ndf_excel = pd.read_excel(buffer, sheet_name=\"Hoja1\")\ndf_excel\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>A</th>\n      <th>B</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>20</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>30</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.callout-tip}\n**Por qu√© hacemos esto**  \nPorque te permite aprender `read_excel()` sin depender de archivos externos ni internet.\n:::\n\n---\n\n## 5. Aplicaci√≥n con datos reales (opcional, online)\n\nTodo lo de esta secci√≥n **depende de internet** y puede fallar en renderizaci√≥n local.  \nPor eso, en el manual lo dejamos **comentado** (`eval: false`).  \nEn **Google Colab** suele funcionar mejor.\n\n---\n\n### 5.1 Bases de ejemplo (wooldridge)\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# En VSCode: pip install wooldridge\n# En Colab:  !pip -q install wooldridge\nimport wooldridge as woo\n\nwage1 = woo.dataWoo(\"wage1\")\nwage1.head()\n```\n:::\n\n\n---\n\n### 5.2 Datos financieros y macro (FRED / Stooq / Yahoo Finance)\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# En Colab:\n# !pip -q install pandas_datareader yfinance\n\nimport pandas_datareader as pdr\nimport yfinance as yf\n\nwti = pdr.data.DataReader(\n    name=\"DCOILWTICO\",\n    data_source=\"fred\",\n    start=\"2014-01-01\",\n    end=\"2024-12-31\"\n)\n\naapl = pdr.data.DataReader(\n    name=\"AAPL\",\n    data_source=\"stooq\",\n    start=\"2017-01-01\",\n    end=\"2024-12-31\"\n)\n\nbtc = yf.download(\n    \"BTC-USD\",\n    start=\"2017-01-01\",\n    end=\"2024-12-31\",\n    auto_adjust=False\n)\n\nwti.tail(), aapl.head(), btc.head()\n```\n:::\n\n\n---\n\n### 5.3 Datos desde un enlace (Google Drive)\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndf_online = pd.read_table(\n    \"https://drive.google.com/uc?id=TU_ID\",\n    sep=r\"\\s+\"\n)\ndf_online.head()\n```\n:::\n\n\n---\n\n## Ejercicios propuestos\n\n1) **Lectura sin encabezado**  \n   Crea un CSV sin encabezado con 4 columnas (puedes copiar el ejemplo del cap√≠tulo). L√©elo con `read_csv` y asigna los nombres `[\"a\",\"b\",\"c\",\"d\"]`.\n\n   **Respuesta esperada:** un `DataFrame` con columnas exactamente `a, b, c, d` y 3 filas.\n\n2) **Separadores ‚Äúraros‚Äù**  \n   Crea un texto donde las columnas est√©n separadas por varios espacios (no uno). L√©elo con `read_table` usando `sep=r\"\\s+\"`.\n\n   **Respuesta esperada:** un `DataFrame` con las columnas correctas (sin que se junte todo en una sola columna).\n\n3) **Exportaci√≥n consistente**  \n   Toma un `DataFrame` cualquiera del cap√≠tulo y guarda:\n   - un CSV sin √≠ndice,\n   - un Excel sin √≠ndice.\n\n   **Respuesta esperada:** dos archivos creados (`.csv` y `.xlsx`) sin una columna extra de √≠ndice.\n\n4) **Excel con hojas**  \n   Crea un Excel en memoria con dos hojas (`Hoja1`, `Hoja2`), cada una con un DataFrame distinto. Luego lee solo `Hoja2`.\n\n   **Respuesta esperada:** `read_excel(..., sheet_name=\"Hoja2\")` devuelve exactamente la tabla de `Hoja2`.\n\n5) **Mini-proyecto**  \n   Crea un `DataFrame` con columnas `ventas` y `clientes`. Calcula `ventas_por_cliente`, luego guarda el resultado en CSV.\n\n   **Respuesta esperada:** un `DataFrame` con 3 columnas (`ventas`, `clientes`, `ventas_por_cliente`) y un CSV con esas mismas columnas.\n\n---\n\n::: {.content-visible when-format=\"pdf\"}\n## Glosario (para Colab)\n\n- **DataFrame**: tabla de datos en `pandas`.\n- **CSV**: archivo de texto con valores separados por comas.\n- **sep / delimiter**: separador entre columnas.\n- **header**: indica si el archivo trae nombres de columnas.\n- **ruta**: ubicaci√≥n del archivo en tu computador.\n- **relativa**: ruta desde la carpeta del proyecto.\n- **absoluta**: ruta completa (m√°s fr√°gil).\n:::\n\n",
    "supporting": [
      "03-datos-externos_files\\figure-pdf"
    ],
    "filters": []
  }
}