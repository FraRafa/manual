{
  "hash": "3588923b8a0b941b8a1a39c1defeb3f1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Cap√≠tulo 7 ‚Äî Intervalos de confianza e inferencia (t-test)\"\n---\n\n[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/07-intervalos-de-confianza-e-inferencia.ipynb){.btn .btn-success target=\"_blank\"}\n\n\n::: {.callout-note}\n## Objetivos del cap√≠tulo\n\nVas a aprender a programar (en Python) c√≥mo:\n\n- construir **intervalos de confianza** paso a paso,\n- calcular **estad√≠stico t**, **valores cr√≠ticos** y **valor p**,\n- usar `scipy.stats.ttest_1samp` para hacer una prueba t autom√°ticamente,\n- interpretar ‚Äúuna cola‚Äù vs ‚Äúdos colas‚Äù desde el c√≥digo.\n:::\n\n::: {.column-margin}\n<details>\n<summary><strong>Glosario</strong></summary>\n\n- **estimador**: n√∫mero calculado con la muestra (ej. promedio).\n- **error est√°ndar (SE)**: desviaci√≥n del estimador; t√≠picamente `s / sqrt(n)`.\n- **ddof=1**: ‚Äúgrados de libertad‚Äù para desviaci√≥n est√°ndar muestral.\n- **cuantil**: punto de corte; en `scipy` se calcula con `ppf`.\n- **valor cr√≠tico**: cuantil usado para decidir rechazo.\n- **valor p**: probabilidad (bajo H0) de observar un estad√≠stico tan extremo.\n- **una cola / dos colas**: forma de definir qu√© significa ‚Äúextremo‚Äù.\n</details>\n:::\n\n---\n\n## 1. Intervalos de confianza con una muestra (ejemplo local)\n\nTrabajaremos con una muestra peque√±a (sin depender de internet).\n\n### 1.1 Datos (variaci√≥n en una tasa)\n\n::: {#73b63527 .cell execution_count=2}\n``` {.python .cell-code}\n# Base de datos de \"tasas de desperdicio\" (TD) para una muestra de 20 empresas\nTD87 = np.array([10, 1, 6, .45, 1.25, 1.3, 1.06, 3, 8.18, 1.67, .98, 1, .45, 5.03, 8, 9, 18, .28, 7, 3.97])\nTD88 = np.array([3, 1, 5, .5, 1.54, 1.5, .8, 2, .67, 1.17, .51, .5, .61, 6.7, 4, 7, 19, .2, 5, 3.83])\n\nvariacion = TD88 - TD87\nn = len(variacion)\n\nbaseTD = pd.DataFrame({\n    \"Empresa\": np.arange(1, n + 1),\n    \"Tasa de desperdicio (1987)\": TD87,\n    \"Tasa de desperdicio (1988)\": TD88,\n    \"Variaci√≥n\": variacion\n})\nbaseTD.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Empresa</th>\n      <th>Tasa de desperdicio (1987)</th>\n      <th>Tasa de desperdicio (1988)</th>\n      <th>Variaci√≥n</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>10.00</td>\n      <td>3.00</td>\n      <td>-7.00</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>1.00</td>\n      <td>1.00</td>\n      <td>0.00</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>6.00</td>\n      <td>5.00</td>\n      <td>-1.00</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>0.45</td>\n      <td>0.50</td>\n      <td>0.05</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>1.25</td>\n      <td>1.54</td>\n      <td>0.29</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave\n\n- `np.array([...])` crea un arreglo num√©rico.\n- `variacion = TD88 - TD87` resta elemento a elemento.\n- `len(variacion)` devuelve el tama√±o de la muestra.\n- `pd.DataFrame({...})` crea una tabla con columnas.\n:::\n\n---\n\n### 1.2 Promedio muestral\n\n::: {#1b7f47b0 .cell execution_count=3}\n``` {.python .cell-code}\npromedio_var = np.mean(variacion)\nprint(f\"Variaci√≥n promedio: {promedio_var:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVariaci√≥n promedio: -1.1545\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (promedio)\n\n- `np.mean(x)` calcula el promedio de `x`.\n- `f\"...\"` (f-string) permite formatear con decimales: `{valor:.4f}`.\n:::\n\n---\n\n### 1.3 Desviaci√≥n est√°ndar, error est√°ndar y cuantil t\n\n::: {#e102d78e .cell execution_count=4}\n``` {.python .cell-code}\n# Desviaci√≥n est√°ndar muestral (ddof=1)\ndest_var = np.std(variacion, ddof=1)\nprint(f\"Desviaci√≥n est√°ndar muestral: {dest_var:.4f}\")\n\n# Error est√°ndar del promedio: s / sqrt(n)\nse_var = dest_var / np.sqrt(n)\nprint(f\"Error est√°ndar del promedio: {se_var:.4f}\")\n\n# Cuantil 0.975 de t(n-1) para IC 95% bilateral\nc = stats.t.ppf(0.975, n - 1)\nprint(f\"Cuantil t(0.975, {n-1}): {c:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDesviaci√≥n est√°ndar muestral: 2.4006\nError est√°ndar del promedio: 0.5368\nCuantil t(0.975, 19): 2.0930\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (std, SE y ppf)\n\n- `np.std(x, ddof=1)` usa la desviaci√≥n est√°ndar **muestral**.\n- `np.sqrt(n)` es la ra√≠z cuadrada de `n`.\n- `stats.t.ppf(q, df)` devuelve el cuantil `q` de una t con `df` grados de libertad.\n:::\n\n---\n\n### 1.4 Intervalo de confianza al 95%\n\n::: {#2b645b91 .cell execution_count=5}\n``` {.python .cell-code}\nLI95 = promedio_var - c * se_var\nLS95 = promedio_var + c * se_var\nprint(f\"IC 95%: [{LI95:.4f}, {LS95:.4f}]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIC 95%: [-2.2780, -0.0310]\n```\n:::\n:::\n\n\n---\n\n## 2. Prueba t (manual): una cola\n\nQueremos contrastar si el promedio es **menor que 0** (una cola a la izquierda).\n\n### 2.1 Estad√≠stico t y valor cr√≠tico\n\n::: {#6240bf28 .cell execution_count=6}\n``` {.python .cell-code}\n# Estad√≠stico t: (promedio - mu0) / SE; aqu√≠ mu0 = 0\nest_t_manual = promedio_var / se_var\nprint(f\"t (manual): {est_t_manual:.4f}\")\n\n# Valor cr√≠tico a una cola (izquierda) al 5%\nvalc_1cola_izq = stats.t.ppf(0.05, n - 1)\nprint(f\"Valor cr√≠tico (1 cola, izq, 5%): {valc_1cola_izq:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nt (manual): -2.1507\nValor cr√≠tico (1 cola, izq, 5%): -1.7291\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (t y valor cr√≠tico)\n\n- `stats.t.ppf(0.05, df)` da el cuantil del 5% (cola izquierda).\n- La regla t√≠pica (cola izquierda): rechazar si `t` es **menor** que el valor cr√≠tico.\n:::\n\n---\n\n### 2.2 Valor p (manual): una cola\n\n::: {#95a6f0d7 .cell execution_count=7}\n``` {.python .cell-code}\nvalorp_manual = stats.t.cdf(est_t_manual, n - 1)\nprint(f\"Valor p (1 cola, izq): {valorp_manual:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValor p (1 cola, izq): 0.0223\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (valor p)\n\n- `stats.t.cdf(t, df)` devuelve `P(T ‚â§ t)` si `T ~ t(df)`.\n- En cola izquierda, ese valor es exactamente el **valor p**.\n:::\n\n---\n\n## 3. Prueba t autom√°tica (`ttest_1samp`)\n\n::: {#959811dc .cell execution_count=8}\n``` {.python .cell-code}\ntest_auto = stats.ttest_1samp(variacion, popmean=0)  # por defecto: bilateral\nest_t_auto = test_auto.statistic\n\n# Para una cola (izquierda), si esperas un t negativo:\nvalorp_1cola = test_auto.pvalue / 2\n\nprint(f\"t (autom√°tico): {est_t_auto:.4f}\")\nprint(f\"valor p (bilateral): {test_auto.pvalue:.4f}\")\nprint(f\"valor p (una cola): {valorp_1cola:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nt (autom√°tico): -2.1507\nvalor p (bilateral): 0.0446\nvalor p (una cola): 0.0223\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (`ttest_1samp`)\n\n- `stats.ttest_1samp(muestra, popmean=mu0)` hace una t con 1 muestra.\n- Devuelve un objeto con `.statistic` y `.pvalue`.\n- Si tu hip√≥tesis es de **una cola**, normalmente divides entre 2 (con el signo correcto).\n:::\n\n---\n\n## 4. Ejemplo pr√°ctico con una base ‚Äútipo auditor√≠a‚Äù (local)\n\nAqu√≠ usamos un ejemplo peque√±o con una variable `y` que toma valores `-1, 0, 1`:\n\n- `y = -1`: favorece al grupo A\n- `y = 0`: decisi√≥n igual\n- `y = 1`: favorece al grupo B\n\n::: {#a00eef61 .cell execution_count=9}\n``` {.python .cell-code}\naudit_like = pd.DataFrame({\n    \"y\": [-1, 0, 0, -1, 1, 0, -1, 0, 0, 1,\n          0, 0, -1, 0, 1, 0, 0, -1, 0, 0,\n          1, 0, -1, 0, 0, 0, -1, 0, 0, 1]\n})\naudit_like[\"y\"].value_counts()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\ny\n 0    18\n-1     7\n 1     5\nName: count, dtype: int64\n```\n:::\n:::\n\n\n---\n\n### 4.1 Intervalos de confianza (95% y 99%) usando normalidad\n\n::: {#4e44d0bf .cell execution_count=10}\n``` {.python .cell-code}\ny = audit_like[\"y\"]\n\npromedio_y = np.mean(y)\nn = len(y)\ndesv_est_y = np.std(y, ddof=1)\nse_y = desv_est_y / np.sqrt(n)\n\nc95 = stats.norm.ppf(0.975)\nc99 = stats.norm.ppf(0.995)\n\nLI95 = promedio_y - c95 * se_y\nLS95 = promedio_y + c95 * se_y\n\nLI99 = promedio_y - c99 * se_y\nLS99 = promedio_y + c99 * se_y\n\nprint(f\"IC 95%: [{LI95:.4f}, {LS95:.4f}]\")\nprint(f\"IC 99%: [{LI99:.4f}, {LS99:.4f}]\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIC 95%: [-0.2956, 0.1622]\nIC 99%: [-0.3675, 0.2342]\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (cuantiles normales)\n\n- `stats.norm.ppf(0.975)` es el cuantil para IC 95% bilateral (‚âà 1.96).\n- `stats.norm.ppf(0.995)` es el cuantil para IC 99% bilateral (‚âà 2.576).\n:::\n\n---\n\n### 4.2 Prueba t sobre el promedio de `y`\n\n::: {#dcee447f .cell execution_count=11}\n``` {.python .cell-code}\ntest_auto = stats.ttest_1samp(y, popmean=0)  # bilateral\nest_t_auto = test_auto.statistic\nvalorp_auto = test_auto.pvalue\n\nvalc_2colas = stats.t.ppf(0.025, n - 1)  # cuantil de cola izquierda\n\nprint(f\"promedio_y: {promedio_y:.4f}\")\nprint(f\"t (autom√°tico): {est_t_auto:.4f}\")\nprint(f\"valor cr√≠tico (2 colas): {valc_2colas:.4f}\")\nprint(f\"valor p (2 colas): {valorp_auto:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npromedio_y: -0.0667\nt (autom√°tico): -0.5708\nvalor cr√≠tico (2 colas): -2.0452\nvalor p (2 colas): 0.5725\n```\n:::\n:::\n\n\n---\n\n## 5. Aplicaci√≥n con datos reales (opcional, online)\n\nSi quieres replicar este flujo con un dataset real, puedes usar paquetes de datasets educativos.  \nEste bloque queda desactivado en Quarto (para no depender de internet o instalaci√≥n).\n\n::: {#2d351fb8 .cell execution_count=12}\n``` {.python .cell-code}\n# En VSCode: pip install wooldridge\n# En Colab:  !pip -q install wooldridge\nimport wooldridge as woo\nfrom scipy import stats\nimport numpy as np\n\naudit = woo.dataWoo(\"audit\")\n\ny = audit[\"y\"]\npromedio_y = np.mean(y)\nn = len(y)\ndesv_est_y = np.std(y, ddof=1)\nse_y = desv_est_y / np.sqrt(n)\n\nc95 = stats.norm.ppf(0.975)\nLI95 = promedio_y - c95 * se_y\nLS95 = promedio_y + c95 * se_y\nprint(f\"IC 95%: [{LI95:.4f}, {LS95:.4f}]\")\n\ntest_auto = stats.ttest_1samp(y, popmean=0)\nprint(test_auto)\n```\n:::\n\n\n---\n\n## Ejercicios propuestos\n\n1) **IC al 95%**  \n   Con la variable `variacion`, calcula el IC 95% usando t (`ppf(0.975, n-1)`).\n\n   **Respuesta esperada:** dos n√∫meros (LI, LS).\n\n2) **Prueba t (manual)**  \n   Con `variacion`, calcula `t = promedio / SE` y el valor cr√≠tico de cola izquierda al 5%.\n\n   **Respuesta esperada:** un `t` (negativo) y un valor cr√≠tico (negativo).\n\n3) **Valor p (una cola)**  \n   Con tu `t` manual, calcula `stats.t.cdf(t, n-1)`.\n\n   **Respuesta esperada:** un n√∫mero peque√±o (menor que 0.05 si hay evidencia).\n\n4) **Autom√°tico vs manual**  \n   Compara el `t` manual con `stats.ttest_1samp(variacion, 0).statistic`.\n\n   **Respuesta esperada:** valores muy cercanos (diferencias por redondeo).\n\n5) **IC 99% (normal)**  \n   Con `audit_like[\"y\"]`, calcula el IC 99% usando `stats.norm.ppf(0.995)`.\n\n   **Respuesta esperada:** intervalo m√°s ancho que el IC 95%.\n\n6) **Dos colas**  \n   Con `audit_like[\"y\"]`, ejecuta `ttest_1samp(y, 0)` y reporta el `pvalue`.\n\n   **Respuesta esperada:** un n√∫mero entre 0 y 1.\n\n---\n\n::: {.content-visible when-format=\"pdf\"}\n## Glosario (para Colab)\n\n- **SE**: error est√°ndar del promedio.\n- **ddof=1**: ajuste para desviaci√≥n est√°ndar muestral.\n- **ppf**: cuantil (inversa de CDF).\n- **t-test 1 muestra**: prueba sobre el promedio contra un valor `mu0`.\n- **una cola / dos colas**: definici√≥n de ‚Äúextremo‚Äù en la prueba.\n:::\n\n",
    "supporting": [
      "07-intervalos-de-confianza-e-inferencia_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}