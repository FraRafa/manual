{
  "hash": "0969b5ed623c91496201440128a1fc55",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Cap√≠tulo 7 ‚Äî Intervalos de confianza e inferencia (t-test)\"\n---\n\n[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/07-intervalos-de-confianza-e-inferencia.ipynb){.btn .btn-success target=\"_blank\"}\n\n\n::: {.callout-note}\n## Objetivos del cap√≠tulo\n\nEn este cap√≠tulo vas a programar (en Python) el flujo completo de inferencia con una muestra:\n\n- calcular un **intervalo de confianza (IC)** para un promedio,\n- construir una **prueba t** ‚Äúa mano‚Äù: estad√≠stico t, valor cr√≠tico y valor p,\n- comparar con la versi√≥n autom√°tica `ttest_1samp`,\n- evitar errores t√≠picos: **`ddof`**, **una cola vs dos colas**, y **cuantiles mal puestos**.\n:::\n\n::: {.column-margin}\n<details>\n<summary><strong>Glosario</strong></summary>\n\n- **estimador**: cantidad calculada con la muestra (ej. promedio).\n- **SE (error est√°ndar)**: variabilidad del estimador; t√≠pico `s / sqrt(n)`.\n- **ddof=1**: ajuste de ‚Äúgrados de libertad‚Äù para la desviaci√≥n est√°ndar muestral.\n- **cuantil / ppf**: ‚Äúpunto de corte‚Äù de una distribuci√≥n; `ppf(q, df)`.\n- **valor cr√≠tico**: cuantil que delimita la regi√≥n de rechazo.\n- **valor p**: probabilidad (bajo H0) de ver un estad√≠stico igual o m√°s extremo.\n- **una cola / dos colas**: define qu√© significa ‚Äúextremo‚Äù.\n</details>\n:::\n\n---\n\n## 1. Una muestra: datos y objetivo\n\nVamos a trabajar con una muestra peque√±a (sin depender de internet).  \nTenemos una medida en dos a√±os y queremos analizar la **variaci√≥n**.\n\n---\n\n## 2. Construcci√≥n de la base y variable de inter√©s\n\n::: {#da3c2ede .cell execution_count=2}\n``` {.python .cell-code}\nTD87 = np.array([10, 1, 6, .45, 1.25, 1.3, 1.06, 3, 8.18, 1.67, .98, 1, .45, 5.03, 8, 9, 18, .28, 7, 3.97])\nTD88 = np.array([3, 1, 5, .5, 1.54, 1.5, .8, 2, .67, 1.17, .51, .5, .61, 6.7, 4, 7, 19, .2, 5, 3.83])\n\nvariacion = TD88 - TD87\nn = len(variacion)\n\nbaseTD = pd.DataFrame({\n    \"Empresa\": np.arange(1, n + 1),\n    \"Tasa (1987)\": TD87,\n    \"Tasa (1988)\": TD88,\n    \"Variaci√≥n\": variacion\n})\n\nbaseTD.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Empresa</th>\n      <th>Tasa (1987)</th>\n      <th>Tasa (1988)</th>\n      <th>Variaci√≥n</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>10.00</td>\n      <td>3.00</td>\n      <td>-7.00</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>1.00</td>\n      <td>1.00</td>\n      <td>0.00</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>6.00</td>\n      <td>5.00</td>\n      <td>-1.00</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>0.45</td>\n      <td>0.50</td>\n      <td>0.05</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>1.25</td>\n      <td>1.54</td>\n      <td>0.29</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (lo m√≠nimo que debes dominar)\n\n- `np.array([...])`: crea un arreglo num√©rico.\n- `TD88 - TD87`: resta **elemento a elemento** (vectorizada).\n- `np.arange(1, n+1)`: n√∫meros 1,2,...,n.\n- `pd.DataFrame({...})`: arma una tabla por columnas.\n:::\n\n::: {.callout-tip}\n### Tip r√°pido\nSi `TD87` y `TD88` no tienen el mismo tama√±o, la resta falla.  \nChequea con `len(TD87)` y `len(TD88)` antes de restar.\n:::\n\n---\n\n## 3. Intervalo de confianza para el promedio (con t)\n\n### 3.1 Promedio, desviaci√≥n est√°ndar y error est√°ndar\n\n::: {#6a8187b1 .cell execution_count=3}\n``` {.python .cell-code}\npromedio = np.mean(variacion)\ns = np.std(variacion, ddof=1)        # desviaci√≥n est√°ndar muestral\nse = s / np.sqrt(n)                 # error est√°ndar del promedio\n\npromedio, s, se\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n(np.float64(-1.1544999999999999),\n np.float64(2.4006391144640498),\n np.float64(0.5367992249386514))\n```\n:::\n:::\n\n\n::: {.callout-note}\n### C√≥mo leer esta sintaxis\n\n- `np.mean(x)` calcula el promedio de `x`.\n- `np.std(x, ddof=1)` usa **ddof=1**: esto es la desviaci√≥n est√°ndar **muestral** (no poblacional).\n- `se = s / sqrt(n)` es el error est√°ndar del promedio.\n:::\n\n::: {.callout-warning}\n### Error com√∫n #1: olvidar `ddof=1`\n\nSi usas `np.std(x)` sin `ddof=1`, obtienes la desviaci√≥n est√°ndar **poblacional**.  \nPara inferencia t√≠pica con muestra, eso te cambia el SE y el IC.\n:::\n\n---\n\n### 3.2 Cuantil t y el IC 95% (bilateral)\n\nPara un IC 95% bilateral:\n\n- Œ± = 0.05\n- colas: Œ±/2 = 0.025 en cada cola\n- por eso el cuantil es **0.975** (1 ‚àí 0.025)\n\n::: {#c0b4898d .cell execution_count=4}\n``` {.python .cell-code}\nc = stats.t.ppf(0.975, n - 1)\nLI95 = promedio - c * se\nLS95 = promedio + c * se\nLI95, LS95\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n(np.float64(-2.2780336901843095), np.float64(-0.030966309815690485))\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (ppf)\n\n- `stats.t.ppf(q, df)` devuelve el cuantil `q` de una t con `df` grados de libertad.\n- Para IC bilateral al 95%: `q = 0.975`, `df = n - 1`.\n:::\n\n::: {.callout-warning}\n### Error com√∫n #2: usar 0.95 en vez de 0.975\nPara IC bilateral necesitas 0.975, no 0.95.  \nUsar 0.95 te da un IC **m√°s estrecho** de lo correcto.\n:::\n\n---\n\n## 4. Prueba t ‚Äúmanual‚Äù (una cola a la izquierda)\n\nAhora probamos si el promedio de la variaci√≥n es **menor que 0**:\n\n- H0: Œº = 0\n- H1: Œº < 0\n\n### 4.1 Estad√≠stico t\n\n::: {#263bac78 .cell execution_count=5}\n``` {.python .cell-code}\nmu0 = 0\nt_manual = (promedio - mu0) / se\nt_manual\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nnp.float64(-2.150711003973493)\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (estad√≠stico t)\n- La forma es `(promedio - mu0) / SE`.\n- Si `promedio` es negativo, `t_manual` tiende a ser negativo.\n:::\n\n---\n\n### 4.2 Valor cr√≠tico (cola izquierda al 5%)\n\n::: {#a01a4c32 .cell execution_count=6}\n``` {.python .cell-code}\nval_critico = stats.t.ppf(0.05, n - 1)\nval_critico\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nnp.float64(-1.7291328115213678)\n```\n:::\n:::\n\n\n::: {.callout-tip}\n### Regla de decisi√≥n (cola izquierda)\nRechazas H0 si:\n\n- `t_manual < val_critico`\n:::\n\n---\n\n### 4.3 Valor p (cola izquierda)\n\nEn cola izquierda, el valor p se puede calcular con la CDF:\n\n::: {#bc8153f4 .cell execution_count=7}\n``` {.python .cell-code}\np_una_cola = stats.t.cdf(t_manual, n - 1)\np_una_cola\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nnp.float64(0.02229062646839212)\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Por qu√© esto funciona (en c√≥digo)\n- `stats.t.cdf(t, df)` te da `P(T ‚â§ t)`.\n- En cola izquierda, ‚Äúm√°s extremo‚Äù significa ‚Äúm√°s peque√±o‚Äù.\n:::\n\n::: {.callout-warning}\n### Error com√∫n #3: usar dos colas por accidente\nSi tu hip√≥tesis es **Œº < 0**, el valor p es de **una cola**.  \nUsar dos colas te da un p-value distinto y puede cambiar tu conclusi√≥n.\n:::\n\n---\n\n## 5. Prueba t autom√°tica (`ttest_1samp`)\n\n::: {#da8d9088 .cell execution_count=8}\n``` {.python .cell-code}\ntest = stats.ttest_1samp(variacion, popmean=0)  # por defecto es bilateral\nt_auto = test.statistic\np_bilateral = test.pvalue\n\nt_auto, p_bilateral\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n(np.float64(-2.150711003973493), np.float64(0.04458125293678424))\n```\n:::\n:::\n\n\nPara una cola (izquierda), si `t_auto` es negativo:\n\n::: {#502ddb57 .cell execution_count=9}\n``` {.python .cell-code}\np_una_cola_auto = p_bilateral / 2\np_una_cola_auto\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nnp.float64(0.02229062646839212)\n```\n:::\n:::\n\n\n::: {.callout-tip}\n### Tip: valida el signo antes de dividir entre 2\nDividir entre 2 solo tiene sentido si el estad√≠stico va ‚Äúen la direcci√≥n‚Äù de tu H1.  \nPara H1: Œº < 0, esperas `t` **negativo**.\n:::\n\n---\n\n## 6. Ejemplo pr√°ctico con una variable `y` en {-1, 0, 1} (local)\n\nAqu√≠ usamos un ejemplo tipo ‚Äúauditor√≠a‚Äù con una variable de decisi√≥n:\n\n- `-1`, `0`, `1` (tres resultados posibles).\n\n::: {#4447e616 .cell execution_count=10}\n``` {.python .cell-code}\naudit_like = pd.DataFrame({\n    \"y\": [-1, 0, 0, -1, 1, 0, -1, 0, 0, 1,\n          0, 0, -1, 0, 1, 0, 0, -1, 0, 0,\n          1, 0, -1, 0, 0, 0, -1, 0, 0, 1]\n})\naudit_like[\"y\"].value_counts()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\ny\n 0    18\n-1     7\n 1     5\nName: count, dtype: int64\n```\n:::\n:::\n\n\n### 6.1 IC 95% y 99% usando cuantiles normales\n\n::: {#f33b2740 .cell execution_count=11}\n``` {.python .cell-code}\ny = audit_like[\"y\"]\nn = len(y)\n\npromedio_y = np.mean(y)\ns_y = np.std(y, ddof=1)\nse_y = s_y / np.sqrt(n)\n\nc95 = stats.norm.ppf(0.975)\nc99 = stats.norm.ppf(0.995)\n\nIC95 = (promedio_y - c95 * se_y, promedio_y + c95 * se_y)\nIC99 = (promedio_y - c99 * se_y, promedio_y + c99 * se_y)\n\nIC95, IC99\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n((np.float64(-0.29557037914190526), np.float64(0.1622370458085719)),\n (np.float64(-0.36749713852006516), np.float64(0.23416380518673185)))\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (normal)\n- `stats.norm.ppf(0.975)` ‚âà 1.96 (IC 95% bilateral).\n- `stats.norm.ppf(0.995)` ‚âà 2.576 (IC 99% bilateral).\n:::\n\n---\n\n### 6.2 Prueba t (dos colas) para `y`\n\n::: {#642a45a9 .cell execution_count=12}\n``` {.python .cell-code}\ntest_y = stats.ttest_1samp(y, popmean=0)\ntest_y.statistic, test_y.pvalue\nvalc_2colas = stats.t.ppf(0.025, n - 1)\nprint(f\"t (autom√°tico): {test_y.statistic:.4f}\")\nprint(f\"valor cr√≠tico (2 colas): {valc_2colas:.4f}\")\nprint(f\"valor p (2 colas): {test_y.pvalue:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nt (autom√°tico): -0.5708\nvalor cr√≠tico (2 colas): -2.0452\nvalor p (2 colas): 0.5725\n```\n:::\n:::\n\n\n---\n\n## 7. Aplicaci√≥n con datos reales (opcional, online)\n\n::: {#25bd355e .cell execution_count=13}\n``` {.python .cell-code}\n# En VSCode: pip install wooldridge\n# En Colab:  !pip -q install wooldridge\nimport wooldridge as woo\nimport numpy as np\nfrom scipy import stats\n\naudit = woo.dataWoo(\"audit\")\ny = audit[\"y\"]\n\npromedio_y = np.mean(y)\nn = len(y)\nse_y = np.std(y, ddof=1) / np.sqrt(n)\n\nc95 = stats.norm.ppf(0.975)\nprint(\"IC 95%:\", promedio_y - c95*se_y, promedio_y + c95*se_y)\n\nprint(stats.ttest_1samp(y, popmean=0))\n```\n:::\n\n\n---\n\n## Ejercicios propuestos\n\n1) **IC 95% (t)**  \n   Con `variacion`, calcula el IC 95% usando `ppf(0.975, n-1)`.\n\n   **Respuesta esperada:** dos n√∫meros (LI, LS).\n\n2) **t manual**  \n   Calcula `t_manual = (promedio - 0) / se`.\n\n   **Respuesta esperada:** un n√∫mero (signo depende del promedio).\n\n3) **Valor cr√≠tico (cola izquierda)**  \n   Calcula `stats.t.ppf(0.05, n-1)`.\n\n   **Respuesta esperada:** un n√∫mero negativo.\n\n4) **Valor p (cola izquierda)**  \n   Calcula `stats.t.cdf(t_manual, n-1)`.\n\n   **Respuesta esperada:** n√∫mero entre 0 y 1.\n\n5) **Autom√°tico**  \n   Calcula `stats.ttest_1samp(variacion, 0).statistic`.\n\n   **Respuesta esperada:** muy cercano a `t_manual`.\n\n6) **IC 99% (normal)**  \n   Para `audit_like[\"y\"]`, calcula IC 99% con `stats.norm.ppf(0.995)`.\n\n   **Respuesta esperada:** intervalo m√°s ancho que el IC 95%.\n\n---\n\n::: {.content-visible when-format=\"pdf\"}\n## Glosario (para Colab)\n\n- **SE**: error est√°ndar del promedio.\n- **ddof=1**: ajuste muestral en desviaci√≥n est√°ndar.\n- **ppf**: cuantil (inversa de CDF).\n- **valor cr√≠tico**: punto de corte para decisi√≥n.\n- **valor p**: probabilidad bajo H0.\n:::\n\n",
    "supporting": [
      "07-intervalos-de-confianza-e-inferencia_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}