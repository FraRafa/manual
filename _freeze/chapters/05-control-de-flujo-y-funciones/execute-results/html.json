{
  "hash": "d296b88c42fc2dd7dfb00a0582eab3ce",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Cap√≠tulo 5 ‚Äî Control de flujo y funciones (if, for, while, def)\"\n---\n\n[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/05-control-de-flujo-y-funciones.ipynb){.btn .btn-success target=\"_blank\"}\n\n\n::: {.callout-note}\n## Objetivos del cap√≠tulo\n\nAl terminar este cap√≠tulo vas a poder:\n\n- tomar decisiones con `if / elif / else`,\n- repetir acciones con `for` y `while`,\n- usar `range()` y entender √≠ndices,\n- crear funciones con `def` y devolver resultados con `return`,\n- escribir c√≥digo m√°s limpio y reutilizable.\n:::\n\n---\n\n## 1. Control de flujo: la idea\n\nEn programaci√≥n, *control de flujo* significa decidir:\n\n- **qu√©** se ejecuta (condiciones),\n- **cu√°ntas veces** se ejecuta (bucles),\n- **c√≥mo** reutilizarlo (funciones).\n\n::: {.column-margin}\n<details>\n<summary><strong>Glosario</strong></summary>\n\n- **condici√≥n**: expresi√≥n que da `True` o `False`.\n- **bloque**: grupo de l√≠neas con la misma indentaci√≥n.\n- **indentaci√≥n**: espacios al inicio de la l√≠nea (en Python es obligatoria).\n- **bucle**: repetici√≥n (`for`, `while`).\n- **iterar**: recorrer elementos uno por uno.\n- **funci√≥n**: bloque reutilizable creado con `def`.\n- **return**: devuelve un resultado y termina la funci√≥n.\n</details>\n:::\n\n---\n\n## 2. Condicionales: `if`, `elif`, `else`\n\n### 2.1 El caso m√°s simple\n\n::: {#2f48e0ae .cell execution_count=2}\n``` {.python .cell-code}\nx = 10\n\nif x > 5:\n    print(\"x es mayor que 5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx es mayor que 5\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (if)\n\n- `if condicion:` termina con **dos puntos** `:`\n- lo que va ‚Äúdentro‚Äù del `if` debe ir indentado (normalmente 4 espacios)\n- la condici√≥n debe ser algo que d√© `True` o `False`\n:::\n\n---\n\n### 2.2 Con `else`\n\n::: {#796bb029 .cell execution_count=3}\n``` {.python .cell-code}\nx = 3\n\nif x > 5:\n    print(\"x es mayor que 5\")\nelse:\n    print(\"x NO es mayor que 5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx NO es mayor que 5\n```\n:::\n:::\n\n\n---\n\n### 2.3 Con `elif` (varios casos)\n\n::: {#b9f7fa6d .cell execution_count=4}\n``` {.python .cell-code}\nnota = 16\n\nif nota >= 18:\n    resultado = \"Excelente\"\nelif nota >= 14:\n    resultado = \"Aprobado\"\nelse:\n    resultado = \"Reprobado\"\n\nresultado\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n'Aprobado'\n```\n:::\n:::\n\n\n::: {.callout-tip}\n**Regla mental**  \n`elif` significa ‚Äúsi no fue el anterior, prueba este‚Äù.\n:::\n\n---\n\n## 3. Bucles `for`\n\n### 3.1 Iterar sobre una lista\n\n::: {#1a3bfc38 .cell execution_count=5}\n``` {.python .cell-code}\nnombres = [\"Ana\", \"Luis\", \"Mar√≠a\"]\n\nfor nombre in nombres:\n    print(nombre)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAna\nLuis\nMar√≠a\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (for)\n\n- `for variable in coleccion:` recorre elemento por elemento\n- en cada vuelta, `variable` toma el siguiente valor\n:::\n\n---\n\n### 3.2 `range()` para repetir un n√∫mero de veces\n\n::: {#f456ffb3 .cell execution_count=6}\n``` {.python .cell-code}\nfor i in range(5):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n3\n4\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (range)\n\n- `range(n)` produce `0, 1, 2, ..., n-1`\n- se usa mucho para contar o para trabajar con √≠ndices\n:::\n\n---\n\n### 3.3 Acumular resultados (sumar, contar, etc.)\n\n::: {#1c00f26a .cell execution_count=7}\n``` {.python .cell-code}\nvalores = [10, 20, 30, 40]\nsuma = 0\n\nfor v in valores:\n    suma = suma + v\n\nsuma\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n100\n```\n:::\n:::\n\n\n---\n\n### 3.4 `break` y `continue`\n\n::: {#de202f88 .cell execution_count=8}\n``` {.python .cell-code}\nnums = [2, 4, 7, 8, 10]\n\nfor n in nums:\n    if n % 2 == 1:\n        print(\"Encontr√© un impar:\", n)\n        break  # corta el bucle\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEncontr√© un impar: 7\n```\n:::\n:::\n\n\n::: {#8c1e3398 .cell execution_count=9}\n``` {.python .cell-code}\nfor n in nums:\n    if n % 2 == 1:\n        continue  # salta esta vuelta\n    print(\"Par:\", n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPar: 2\nPar: 4\nPar: 8\nPar: 10\n```\n:::\n:::\n\n\n::: {.callout-warning}\n**Ojo**  \n`break` termina el bucle por completo.  \n`continue` solo salta la iteraci√≥n actual.\n:::\n\n---\n\n## 4. Bucles `while`\n\nUn `while` repite *mientras la condici√≥n sea verdadera*.\n\n::: {#90ccf8e3 .cell execution_count=10}\n``` {.python .cell-code}\ncontador = 0\n\nwhile contador < 3:\n    print(\"contador =\", contador)\n    contador = contador + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncontador = 0\ncontador = 1\ncontador = 2\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (while)\n\n- `while condicion:` repite mientras la condici√≥n sea `True`\n- si nunca cambias la condici√≥n, puedes crear un bucle infinito\n:::\n\n---\n\n## 5. Funciones (`def`)\n\n### 5.1 Funci√≥n simple\n\n::: {#013f1c23 .cell execution_count=11}\n``` {.python .cell-code}\ndef cuadrado(x):\n    return x**2\n\ncuadrado(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n25\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (def)\n\n- `def nombre(parametros):` define la funci√≥n\n- `return` devuelve un valor y termina la funci√≥n\n- si no hay `return`, la funci√≥n devuelve `None`\n:::\n\n---\n\n### 5.2 Funci√≥n con varios par√°metros y valor por defecto\n\n::: {#c1835136 .cell execution_count=12}\n``` {.python .cell-code}\ndef area_rectangulo(base, altura=1):\n    return base * altura\n\narea_rectangulo(4, 3), area_rectangulo(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n(12, 4)\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (par√°metros por defecto)\n\n- `altura=1` significa: si no pasas `altura`, se usa 1\n- los par√°metros con defecto deben ir al final\n:::\n\n---\n\n### 5.3 Funci√≥n que valida (usa if)\n\n::: {#fc7215bf .cell execution_count=13}\n``` {.python .cell-code}\ndef porcentaje(parte, total):\n    if total == 0:\n        return None\n    return 100 * parte / total\n\nporcentaje(25, 200), porcentaje(1, 0)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n(12.5, None)\n```\n:::\n:::\n\n\n---\n\n## 6. Mini-ejemplo integrador\n\nQueremos: tomar una lista de n√∫meros y quedarnos con los positivos, elev√°ndolos al cuadrado.\n\n::: {#c6f1da66 .cell execution_count=14}\n``` {.python .cell-code}\ndef positivos_al_cuadrado(lista):\n    salida = []\n    for x in lista:\n        if x > 0:\n            salida.append(x**2)\n    return salida\n\npositivos_al_cuadrado([-2, -1, 0, 1, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[1, 4, 9]\n```\n:::\n:::\n\n\n::: {.callout-tip}\n**Idea clave**  \nLas funciones te ayudan a convertir un procedimiento en una herramienta reutilizable.\n:::\n\n---\n\n## Ejercicios propuestos\n\n1) **Condiciones encadenadas**  \n   Dado un n√∫mero `x`, clasif√≠calo como `\"negativo\"`, `\"cero\"` o `\"positivo\"` usando `if/elif/else`.\n\n   **Respuesta esperada:** para `x=-3` ‚Üí `\"negativo\"`, para `x=0` ‚Üí `\"cero\"`, para `x=7` ‚Üí `\"positivo\"`.\n\n2) **Suma condicional**  \n   Dada la lista `L = [1, 2, 3, 4, 5, 6]`, calcula la suma de los n√∫meros **pares** usando un `for`.\n\n   **Respuesta esperada:** `2 + 4 + 6 = 12`.\n\n3) **B√∫squeda con `break`**  \n   Dada la lista `L = [4, 8, 10, 13, 16]`, encuentra el **primer** n√∫mero impar y det√©n el bucle.\n\n   **Respuesta esperada:** el primer impar encontrado es `13`.\n\n4) **`while` con criterio**  \n   Empezando en `x = 1`, duplica `x` hasta que sea mayor o igual a `100`. Cuenta cu√°ntas duplicaciones hiciste.\n\n   **Respuesta esperada:** `x` termina en `128` y el n√∫mero de duplicaciones es `7`.\n\n5) **Funci√≥n con validaci√≥n**  \n   Escribe una funci√≥n `promedio(lista)` que devuelva el promedio. Si la lista est√° vac√≠a, devuelve `None`.\n\n   **Respuesta esperada:** `promedio([10, 20, 30]) = 20.0` y `promedio([]) = None`.\n\n6) **Mini-proyecto**  \n   Escribe una funci√≥n `filtrar_y_transformar(lista)` que:\n   - tome solo los n√∫meros mayores que 10,\n   - les reste 10,\n   - devuelva la nueva lista.\n\n   **Respuesta esperada:** para `[5, 10, 11, 20]` devuelve `[1, 10]`.\n\n---\n\n::: {.content-visible when-format=\"pdf\"}\n## Glosario (para Colab)\n\n- **condici√≥n**: expresi√≥n que da `True` o `False`.\n- **bloque**: l√≠neas con la misma indentaci√≥n.\n- **indentaci√≥n**: espacios al inicio (obligatoria en Python).\n- **bucle**: repetici√≥n (`for`, `while`).\n- **funci√≥n**: bloque reutilizable creado con `def`.\n- **return**: devuelve un resultado y termina la funci√≥n.\n:::\n\n",
    "supporting": [
      "05-control-de-flujo-y-funciones_files"
    ],
    "filters": [],
    "includes": {}
  }
}