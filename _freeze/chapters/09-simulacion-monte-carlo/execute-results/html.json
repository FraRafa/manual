{
  "hash": "6b6d275b89b73741a30fb6a5fcb565b9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Cap√≠tulo 9 ‚Äî Simulaci√≥n de Monte Carlo\"\n---\n\n[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/09-simulacion-monte-carlo.ipynb){.btn .btn-success target=\"_blank\"}\n\n\n::: {.callout-note}\n## Objetivos del cap√≠tulo\n\n- Entender **qu√© significa simular** en Python: repetir un experimento aleatorio muchas veces.\n- Programar una simulaci√≥n para visualizar el **Teorema del L√≠mite Central (TLC)** usando promedios muestrales.\n- Programar una simulaci√≥n de Monte Carlo para estudiar:\n  - la frecuencia de **rechazos** en una prueba t cuando H0 es verdadera (error Tipo I),\n  - la **cobertura** de intervalos de confianza.\n:::\n\n::: {.column-margin}\n<div style=\"margin-top: 1.2rem;\"></div>\n<details>\n<summary><strong>Glosario</strong></summary>\n\n- **Monte Carlo**: repetir muchas veces un experimento aleatorio para aproximar un resultado.\n- **replicaci√≥n**: una corrida/iteraci√≥n de la simulaci√≥n (una vez que ‚Äúrepites‚Äù).\n- **semilla**: n√∫mero que fija el generador aleatorio para reproducibilidad.\n- **TLC / CLT**: el promedio muestral tiende a ser normal cuando n crece.\n- **IID**: independientes e id√©nticamente distribuidas.\n- **cobertura**: proporci√≥n de intervalos que contienen el par√°metro verdadero.\n- **error Tipo I**: rechazar H0 siendo H0 verdadera.\n</details>\n:::\n\n---\n\n## 1. ¬øQu√© es una simulaci√≥n de Monte Carlo (en c√≥digo)?\n\nEn Python, una simulaci√≥n de Monte Carlo casi siempre se ve as√≠:\n\n1) defines una distribuci√≥n o un mecanismo aleatorio,  \n2) repites `r` veces (un bucle),  \n3) guardas resultados en arrays,  \n4) resumes con una tabla, proporci√≥n o gr√°fico.\n\nLa parte clave para programar bien no es ‚Äúestad√≠stica‚Äù, sino:\n\n- **organizar resultados** (arrays),\n- **reproducibilidad** (semilla),\n- **evitar errores de l√≥gica** (√≠ndices, condiciones, acumuladores).\n\n---\n\n## 2. Teorema del L√≠mite Central (TLC) con una poblaci√≥n asim√©trica\n\n### 2.1 Poblaci√≥n (asim√©trica): chi-cuadrado\n\n::: {#850752f0 .cell execution_count=2}\n``` {.python .cell-code}\n# Ejemplo de distribuci√≥n poblacional asim√©trica (chi-cuadrado)\ny = np.linspace(0, 20, num=100)\n\nm = 1  # grados de libertad\nfy = stats.chi2.pdf(y, m)\n\nplt.plot(y, fy, linestyle=\"-\", color=\"black\")\nplt.title(rf\"Distribuci√≥n poblacional: PDF de Y ~ $\\chi^2$({m})\")\nplt.xlabel(\"Y\")\nplt.ylabel(\"f(Y)\")\nplt.grid(alpha=0.4)\nplt.show()\nplt.close()\n\n# Media y varianza poblacionales (para chi-cuadrado con m g.l.)\nEYi = m\nVYi = 2 * m\nprint(f\"Media poblacional: E(Y_i) = {EYi}\\n\")\nprint(f\"Varianza poblacional: Var(Y_i) = {VYi}\\n\")\n```\n\n::: {.cell-output .cell-output-display}\n![](09-simulacion-monte-carlo_files/figure-html/cell-3-output-1.png){width=829 height=520}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nMedia poblacional: E(Y_i) = 1\n\nVarianza poblacional: Var(Y_i) = 2\n\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave\n\n- `np.linspace(a, b, num=k)` crea k puntos entre a y b (√∫til para graficar).\n- `stats.chi2.pdf(y, m)` eval√∫a la PDF en cada punto de `y`.\n- `plt.plot(...)` grafica l√≠neas; `plt.grid()` agrega grilla.\n:::\n\n---\n\n### 2.2 Una muestra y su promedio\n\n::: {#1c05e4c4 .cell execution_count=3}\n``` {.python .cell-code}\n# Definimos el valor semilla (None = resultados distintos cada ejecuci√≥n)\nsemilla = None\n\n# Tama√±o de muestra\nn = 10\n\n# Muestreo (una muestra desde la poblaci√≥n chi-cuadrado)\nmuestra = stats.chi2.rvs(m, size=n, random_state=semilla)\n\n# Promedio de la muestra\ny_promedio = muestra.mean()\nprint(f\"Promedio de la muestra (l√≠nea verde): {y_promedio:.4f}\")\n\n# Gr√°fico: observaciones y promedio\nplt.scatter(np.arange(1, n + 1), muestra, label=\"Observaciones\")\nplt.axhline(y_promedio, color=\"green\", label=\"Promedio muestral\")\nplt.ylabel(\"Y(i)\")\nplt.xlabel(\"Individuo (i)\")\nplt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, -0.12))\nplt.grid()\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPromedio de la muestra (l√≠nea verde): 0.2948\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09-simulacion-monte-carlo_files/figure-html/cell-4-output-2.png){width=829 height=552}\n:::\n:::\n\n\n::: {.callout-warning}\n### Error com√∫n\nSi quieres resultados **reproducibles**, no dejes `semilla = None`.  \nEn ese caso, usa un entero (ej. `semilla = 1`).\n:::\n\n---\n\n### 2.3 Muchas muestras: distribuci√≥n del promedio muestral\n\nAqu√≠ repetimos el muestreo `r` veces y guardamos los promedios en un array.\n\n::: {#84113964 .cell execution_count=4}\n``` {.python .cell-code}\ncampana = True          # si True, sobrepone una normal te√≥rica\nlimites = None          # si quieres un rango fijo, usa limites=(a, b)\nsemilla = None          # semilla base\nn = 5                   # tama√±o de muestra\nr = 1000                # n√∫mero de replicaciones\n\npromedios = np.zeros(r)\n\nfor j in range(r):\n    semilla2 = semilla if semilla is None else semilla + j\n    muestra = stats.chi2.rvs(m, size=n, random_state=semilla2)\n    promedios[j] = muestra.mean()\n\n# Histograma de promedios\nplt.hist(promedios, bins=15, density=True, edgecolor=\"black\", alpha=0.9,\n         label=\"Distribuci√≥n del promedio muestral\")\n\n# Normal te√≥rica aproximada (por TLC): N(E(Y), Var(Y)/n)\nif campana:\n    EYp = EYi\n    VYp = VYi / n\n    if limites is None:\n        x = np.linspace(EYp - 3*np.sqrt(VYp), EYp + 3*np.sqrt(VYp), num=1000)\n    else:\n        x = np.linspace(*limites, num=1000)\n    pdfx = stats.norm.pdf(x, EYp, np.sqrt(VYp))\n    plt.plot(x, pdfx, linewidth=3, label=\"Normal te√≥rica (aprox.)\")\n\nplt.ylabel(\"Densidad\")\nplt.xlabel(\"Promedio muestral\")\nplt.title(\"TLC: histograma del promedio muestral\")\nplt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, -0.12))\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](09-simulacion-monte-carlo_files/figure-html/cell-5-output-1.png){width=829 height=579}\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave (Monte Carlo)\n\n- `np.zeros(r)` reserva un array para guardar `r` resultados.\n- Dentro del bucle:\n  - generas una muestra aleatoria,\n  - calculas su promedio,\n  - lo guardas en `promedios[j]`.\n:::\n\n::: {.callout-tip}\n### Tip: controla semillas por iteraci√≥n\nLa l√≠nea `semilla2 = semilla + j` sirve para que cada r√©plica sea distinta, pero reproducible.\n:::\n\n---\n\n### 2.4 Ley de los grandes n√∫meros (promedio vs n)\n\n::: {#1c6c4e61 .cell execution_count=5}\n``` {.python .cell-code}\nsemilla = None\nnmax = 1000\n\npromedios_nmax = np.zeros(nmax - 2)\n\nfor j in range(2, nmax):\n    muestra = stats.chi2.rvs(m, size=j, random_state=semilla)\n    promedios_nmax[j - 2] = muestra.mean()\n\nplt.plot(promedios_nmax)\nplt.axhline(EYi, color=\"red\")\nplt.grid()\nplt.xlabel(\"Tama√±o de muestra (n)\")\nplt.ylabel(\"Promedio muestral\")\nplt.title(\"Ley de los grandes n√∫meros: promedio muestral ‚Üí media poblacional\")\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](09-simulacion-monte-carlo_files/figure-html/cell-6-output-1.png){width=840 height=517}\n:::\n:::\n\n\n---\n\n## 3. Simulaci√≥n de pruebas t e intervalos de confianza\n\n### 3.1 Poblaci√≥n normal (para simular)\n\n::: {#2bc4e449 .cell execution_count=6}\n``` {.python .cell-code}\nmu = 40                 # media poblacional\nsigma = np.sqrt(100)    # desviaci√≥n est√°ndar poblacional\n\ny = np.linspace(10, 70, num=400)\nfy = stats.norm.pdf(y, mu, sigma)\n\nplt.plot(y, fy)\nplt.grid()\nplt.title(\"Poblaci√≥n normal: PDF\")\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](09-simulacion-monte-carlo_files/figure-html/cell-7-output-1.png){width=827 height=493}\n:::\n:::\n\n\n---\n\n### 3.2 Una muestra: promedio, desviaci√≥n y SE\n\n::: {#630b1599 .cell execution_count=7}\n``` {.python .cell-code}\nsemilla = 1\nn = 10\n\nmuestra = stats.norm.rvs(mu, sigma, size=n, random_state=semilla)\n\npromedio_m = np.mean(muestra)\ndesv_est_m = np.std(muestra, ddof=1)\nerror_est = desv_est_m / np.sqrt(n)\n\nprint(f\"Promedio muestral: {promedio_m:.4f}\\n\")\nprint(f\"Desviaci√≥n est√°ndar muestral: {desv_est_m:.4f}\\n\")\nprint(f\"Error est√°ndar: {error_est:.4f}\")\n\nplt.scatter(np.arange(1, n + 1), muestra, label=\"Muestra\")\nplt.axhline(promedio_m, color=\"green\", label=\"Promedio\")\nplt.grid()\nplt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, -0.12))\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPromedio muestral: 39.0286\n\nDesviaci√≥n est√°ndar muestral: 12.5532\n\nError est√°ndar: 3.9697\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09-simulacion-monte-carlo_files/figure-html/cell-8-output-2.png){width=800 height=552}\n:::\n:::\n\n\n::: {.callout-warning}\n### Error com√∫n: `ddof`\nPara inferencia con muestras, usa `np.std(..., ddof=1)` (desviaci√≥n est√°ndar muestral).\n:::\n\n---\n\n### 3.3 Prueba t (bilateral) y valor cr√≠tico\n\n::: {#9af21093 .cell execution_count=8}\n``` {.python .cell-code}\nalpha = 0.05\nmu0 = mu  # H0 verdadera en este experimento\n\nprueba_t = stats.ttest_1samp(muestra, popmean=mu0)\nvalor_crit = stats.t.ppf(1 - alpha/2, df=n - 1)\n\nestadistico_t = prueba_t.statistic\nvalorp = prueba_t.pvalue\n\nprint(f\"Estad√≠stico t: {estadistico_t:.4f}\\n\")\nprint(f\"Valor cr√≠tico ({(1-alpha)*100:.2f}% confianza): {valor_crit:.2f}\\n\")\nprint(f\"Valor p: {valorp:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEstad√≠stico t: -0.2447\n\nValor cr√≠tico (95.00% confianza): 2.26\n\nValor p: 0.8122\n```\n:::\n:::\n\n\n::: {.callout-note}\n### Sintaxis clave\n- `ttest_1samp(muestra, popmean=mu0)` devuelve `.statistic` y `.pvalue`.\n- `t.ppf(1 - alpha/2, df=n-1)` es el cuantil bilateral para el valor cr√≠tico.\n:::\n\n---\n\n### 3.4 Intervalo de confianza e indicador ‚Äú¬øcontiene mu?‚Äù\n\n::: {#be935999 .cell execution_count=9}\n``` {.python .cell-code}\nLI = promedio_m - valor_crit * error_est\nLS = promedio_m + valor_crit * error_est\n\nprint(f\"IC al {(1-alpha)*100:.2f}%: [{LI:.2f}, {LS:.2f}]\\n\")\nprint(f\"¬øEl intervalo contiene a mu? {'S√≠' if (mu >= LI and mu <= LS) else 'No'}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIC al 95.00%: [30.05, 48.01]\n\n¬øEl intervalo contiene a mu? S√≠\n```\n:::\n:::\n\n\n---\n\n### 3.5 Monte Carlo: repetir r veces (p-values, error tipo I y cobertura)\n\n::: {#69d26703 .cell execution_count=10}\n``` {.python .cell-code}\nmu = 40\nsigma = np.sqrt(100)\n\nsemilla = 1\nn = 10\nalpha = 0.05\nmu0 = mu\nr = 20\n\nresultados_valores_p = np.zeros(r)\nresultados_error1 = np.zeros(r)\nresultados_LI = np.zeros(r)\nresultados_LS = np.zeros(r)\nresultados_intervalo_mal = np.zeros(r)\n\nfor i in range(r):\n    semilla2 = None if semilla is None else semilla + i\n\n    muestra = stats.norm.rvs(mu, sigma, size=n, random_state=semilla2)\n\n    promedio_m = np.mean(muestra)\n    desv_est_m = np.std(muestra, ddof=1)\n    error_est = desv_est_m / np.sqrt(n)\n\n    prueba_t = stats.ttest_1samp(muestra, popmean=mu0)\n    valor_crit = stats.t.ppf(1 - alpha/2, df=n - 1)\n\n    valorp = prueba_t.pvalue\n    resultados_valores_p[i] = valorp\n\n    if valorp < alpha:\n        resultados_error1[i] = 1\n\n    LI = promedio_m - valor_crit * error_est\n    LS = promedio_m + valor_crit * error_est\n    resultados_LI[i] = LI\n    resultados_LS[i] = LS\n\n    if (mu < LI) or (mu > LS):\n        resultados_intervalo_mal[i] = 1\n\ntabla_valores_p = pd.DataFrame({\n    \"Valores p\": resultados_valores_p,\n    \"Error Tipo 1\": resultados_error1,\n    \"Lim inferior\": resultados_LI,\n    \"L√≠m superior\": resultados_LS,\n    \"¬øNo contiene mu?\": resultados_intervalo_mal\n})\n\nprint(f\"{tabla_valores_p}\\n\" if r <= 20 else \"M√°s de 20 simulaciones: omitimos tabla\\n\")\nprint(f\"Errores tipo I: {sum(resultados_error1)} de {r} ({sum(resultados_error1)/r*100:.2f}%)\")\nprint(f\"Intervalos que NO contienen mu: {sum(resultados_intervalo_mal)} de {r} ({sum(resultados_intervalo_mal)/r*100:.2f}%)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Valores p  Error Tipo 1  Lim inferior  L√≠m superior  ¬øNo contiene mu?\n0    0.812170           0.0     30.048592     48.008590               0.0\n1    0.106021           0.0     25.735345     41.637656               0.0\n2    0.638300           0.0     32.061999     45.128436               0.0\n3    0.334230           0.0     31.574147     43.187785               0.0\n4    0.491500           0.0     34.962626     49.713357               0.0\n5    0.808156           0.0     29.800708     48.168869               0.0\n6    0.812628           0.0     33.877092     47.604126               0.0\n7    0.512978           0.0     31.488820     55.843483               0.0\n8    0.007517           1.0     31.413388     38.239187               1.0\n9    0.816756           0.0     34.927793     46.268373               0.0\n10   0.441022           0.0     29.081732     45.181874               0.0\n11   0.906862           0.0     30.128664     48.874181               0.0\n12   0.102848           0.0     38.776779     51.164886               0.0\n13   0.797112           0.0     31.495786     46.721771               0.0\n14   0.033067           1.0     30.271250     39.486101               1.0\n15   0.046063           1.0     30.417601     39.894965               1.0\n16   0.490989           0.0     34.941927     49.761617               0.0\n17   0.167283           0.0     38.086729     49.477681               0.0\n18   0.505837           0.0     33.422185     43.492977               0.0\n19   0.871146           0.0     31.840531     47.038261               0.0\n\nErrores tipo I: 3.0 de 20 (15.00%)\nIntervalos que NO contienen mu: 3.0 de 20 (15.00%)\n```\n:::\n:::\n\n\n::: {.callout-tip}\n### Interpretaci√≥n en modo ‚Äúc√≥digo‚Äù\n- `sum(resultados_error1)/r` es una **proporci√≥n** (frecuencia relativa).\n- `resultados_intervalo_mal` marca cuando el IC **falla** en cubrir `mu`.\n:::\n\n---\n\n### 3.6 Visualizar intervalos de confianza (rojo = no cubre mu)\n\n::: {#fe178850 .cell execution_count=11}\n``` {.python .cell-code}\nr_ej = 20  # debe ser <= r\n\nplt.figure(figsize=(3, 5))\nplt.xlim(10, 70)\nplt.ylim(-1, r_ej)\n\nfor i in range(r_ej):\n    color = \"grey\" if (mu > resultados_LI[i] and mu < resultados_LS[i]) else \"red\"\n    plt.plot([resultados_LI[i], resultados_LS[i]], [i, i], linestyle=\"-\", color=color)\n\nplt.axvline(mu, linestyle=\"--\", color=\"green\", linewidth=0.5)\nplt.ylabel(\"No. de simulaci√≥n de Monte Carlo\")\nplt.xlabel(\"Y\")\nplt.title(\"Intervalos de confianza por simulaci√≥n\")\nplt.show()\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](09-simulacion-monte-carlo_files/figure-html/cell-12-output-1.png){width=428 height=563}\n:::\n:::\n\n\n---\n\n## Ejercicios propuestos\n\n1) **Semillas y reproducibilidad**  \n   Ejecuta dos veces una simulaci√≥n con `semilla=None` y luego con `semilla=1`.\n\n   **Respuesta esperada:** con `None` obtienes resultados diferentes; con `1` obtienes resultados id√©nticos.\n\n2) **TLC: cambia n**  \n   Repite la simulaci√≥n de promedios con `n=5`, `n=30` y `n=100`.\n\n   **Respuesta esperada:** el histograma del promedio se vuelve cada vez m√°s parecido a una normal.\n\n3) **Ley de grandes n√∫meros**  \n   Aumenta `nmax` y mira el gr√°fico del promedio.\n\n   **Respuesta esperada:** la serie se estabiliza alrededor de `E(Y)=m`.\n\n4) **Error tipo I con m√°s r**  \n   Cambia `r` a 500 o 1000 y calcula la proporci√≥n `sum(error1)/r`.\n\n   **Respuesta esperada:** la proporci√≥n se acerca a `alpha` (‚âà 0.05).\n\n5) **Cobertura del IC**  \n   Con `r=1000`, calcula `1 - sum(intervalo_mal)/r`.\n\n   **Respuesta esperada:** la cobertura se acerca a `1-alpha` (‚âà 0.95).\n\n6) **Exploraci√≥n**  \n   Cambia `n` de 10 a 30 en la simulaci√≥n t.\n\n   **Respuesta esperada:** los intervalos se vuelven (en promedio) m√°s estrechos y la cobertura se mantiene cercana a 0.95.\n\n---\n\n::: {.content-visible when-format=\"pdf\"}\n## Glosario (para Colab)\n\n- **Monte Carlo**: repetir muchas veces un experimento aleatorio.\n- **semilla**: hace reproducible el azar.\n- **TLC/CLT**: el promedio muestral tiende a normal.\n- **cobertura**: proporci√≥n de intervalos que contienen el valor verdadero.\n- **error Tipo I**: rechazar H0 siendo verdadera.\n:::\n\n",
    "supporting": [
      "09-simulacion-monte-carlo_files"
    ],
    "filters": [],
    "includes": {}
  }
}