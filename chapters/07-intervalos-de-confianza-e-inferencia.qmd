---
title: "Cap√≠tulo 7 ‚Äî Intervalos de confianza e inferencia (t-test)"
---

[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/07-intervalos-de-confianza-e-inferencia.ipynb){.btn .btn-success target="_blank"}

```{python}
#| include: false
# Setup interno (se ejecuta, pero no se muestra en HTML/PDF)
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats

plt.rcParams["figure.figsize"] = (8, 4.5)
plt.rcParams["figure.dpi"] = 120
```

::: {.callout-note}
## Objetivos del cap√≠tulo

En este cap√≠tulo vas a programar (en Python) el flujo completo de inferencia con una muestra:

- calcular un **intervalo de confianza (IC)** para un promedio,
- construir una **prueba t** ‚Äúa mano‚Äù: estad√≠stico t, valor cr√≠tico y valor p,
- comparar con la versi√≥n autom√°tica `ttest_1samp`,
- evitar errores t√≠picos: **`ddof`**, **una cola vs dos colas**, y **cuantiles mal puestos**.
:::

::: {.column-margin}
<details>
<summary><strong>Glosario</strong></summary>

- **estimador**: cantidad calculada con la muestra (ej. promedio).
- **SE (error est√°ndar)**: variabilidad del estimador; t√≠pico `s / sqrt(n)`.
- **ddof=1**: ajuste de ‚Äúgrados de libertad‚Äù para la desviaci√≥n est√°ndar muestral.
- **cuantil / ppf**: ‚Äúpunto de corte‚Äù de una distribuci√≥n; `ppf(q, df)`.
- **valor cr√≠tico**: cuantil que delimita la regi√≥n de rechazo.
- **valor p**: probabilidad (bajo H0) de ver un estad√≠stico igual o m√°s extremo.
- **una cola / dos colas**: define qu√© significa ‚Äúextremo‚Äù.
</details>
:::

---

## 1. Una muestra: datos y objetivo

Vamos a trabajar con una muestra peque√±a (sin depender de internet).  
Tenemos una medida en dos a√±os y queremos analizar la **variaci√≥n**.

> La parte ‚Äúestad√≠stica‚Äù la asumes conocida. Aqu√≠ nos enfocamos en el **c√≥digo** que implementa el procedimiento.

---

## 2. Construcci√≥n de la base y variable de inter√©s

```{python}
TD87 = np.array([10, 1, 6, .45, 1.25, 1.3, 1.06, 3, 8.18, 1.67, .98, 1, .45, 5.03, 8, 9, 18, .28, 7, 3.97])
TD88 = np.array([3, 1, 5, .5, 1.54, 1.5, .8, 2, .67, 1.17, .51, .5, .61, 6.7, 4, 7, 19, .2, 5, 3.83])

variacion = TD88 - TD87
n = len(variacion)

baseTD = pd.DataFrame({
    "Empresa": np.arange(1, n + 1),
    "Tasa (1987)": TD87,
    "Tasa (1988)": TD88,
    "Variaci√≥n": variacion
})

baseTD.head()
```

::: {.callout-note}
### Sintaxis clave (lo m√≠nimo que debes dominar)

- `np.array([...])`: crea un arreglo num√©rico.
- `TD88 - TD87`: resta **elemento a elemento** (vectorizada).
- `np.arange(1, n+1)`: n√∫meros 1,2,...,n.
- `pd.DataFrame({...})`: arma una tabla por columnas.
:::

::: {.callout-tip}
### Tip r√°pido
Si `TD87` y `TD88` no tienen el mismo tama√±o, la resta falla.  
Chequea con `len(TD87)` y `len(TD88)` antes de restar.
:::

---

## 3. Intervalo de confianza para el promedio (con t)

### 3.1 Promedio, desviaci√≥n est√°ndar y error est√°ndar

```{python}
promedio = np.mean(variacion)
s = np.std(variacion, ddof=1)        # desviaci√≥n est√°ndar muestral
se = s / np.sqrt(n)                 # error est√°ndar del promedio

promedio, s, se
```

::: {.callout-note}
### C√≥mo leer esta sintaxis

- `np.mean(x)` calcula el promedio de `x`.
- `np.std(x, ddof=1)` usa **ddof=1**: esto es la desviaci√≥n est√°ndar **muestral** (no poblacional).
- `se = s / sqrt(n)` es el error est√°ndar del promedio.
:::

::: {.callout-warning}
### Error com√∫n #1: olvidar `ddof=1`

Si usas `np.std(x)` sin `ddof=1`, obtienes la desviaci√≥n est√°ndar **poblacional**.  
Para inferencia t√≠pica con muestra, eso te cambia el SE y el IC.
:::

---

### 3.2 Cuantil t y el IC 95% (bilateral)

Para un IC 95% bilateral:

- Œ± = 0.05
- colas: Œ±/2 = 0.025 en cada cola
- por eso el cuantil es **0.975** (1 ‚àí 0.025)

```{python}
c = stats.t.ppf(0.975, n - 1)
LI95 = promedio - c * se
LS95 = promedio + c * se
LI95, LS95
```

::: {.callout-note}
### Sintaxis clave (ppf)

- `stats.t.ppf(q, df)` devuelve el cuantil `q` de una t con `df` grados de libertad.
- Para IC bilateral al 95%: `q = 0.975`, `df = n - 1`.
:::

::: {.callout-warning}
### Error com√∫n #2: usar 0.95 en vez de 0.975
Para IC bilateral necesitas 0.975, no 0.95.  
Usar 0.95 te da un IC **m√°s estrecho** de lo correcto.
:::

---

## 4. Prueba t ‚Äúmanual‚Äù (una cola a la izquierda)

Ahora probamos si el promedio de la variaci√≥n es **menor que 0**:

- H0: Œº = 0
- H1: Œº < 0

### 4.1 Estad√≠stico t

```{python}
mu0 = 0
t_manual = (promedio - mu0) / se
t_manual
```

::: {.callout-note}
### Sintaxis clave (estad√≠stico t)
- La forma es `(promedio - mu0) / SE`.
- Si `promedio` es negativo, `t_manual` tiende a ser negativo.
:::

---

### 4.2 Valor cr√≠tico (cola izquierda al 5%)

```{python}
val_critico = stats.t.ppf(0.05, n - 1)
val_critico
```

::: {.callout-tip}
### Regla de decisi√≥n (cola izquierda)
Rechazas H0 si:

- `t_manual < val_critico`
:::

---

### 4.3 Valor p (cola izquierda)

En cola izquierda, el valor p se puede calcular con la CDF:

```{python}
p_una_cola = stats.t.cdf(t_manual, n - 1)
p_una_cola
```

::: {.callout-note}
### Por qu√© esto funciona (en c√≥digo)
- `stats.t.cdf(t, df)` te da `P(T ‚â§ t)`.
- En cola izquierda, ‚Äúm√°s extremo‚Äù significa ‚Äúm√°s peque√±o‚Äù.
:::

::: {.callout-warning}
### Error com√∫n #3: usar dos colas por accidente
Si tu hip√≥tesis es **Œº < 0**, el valor p es de **una cola**.  
Usar dos colas te da un p-value distinto y puede cambiar tu conclusi√≥n.
:::

---

## 5. Prueba t autom√°tica (`ttest_1samp`)

```{python}
test = stats.ttest_1samp(variacion, popmean=0)  # por defecto es bilateral
t_auto = test.statistic
p_bilateral = test.pvalue

t_auto, p_bilateral
```

Para una cola (izquierda), si `t_auto` es negativo:

```{python}
p_una_cola_auto = p_bilateral / 2
p_una_cola_auto
```

::: {.callout-tip}
### Tip: valida el signo antes de dividir entre 2
Dividir entre 2 solo tiene sentido si el estad√≠stico va ‚Äúen la direcci√≥n‚Äù de tu H1.  
Para H1: Œº < 0, esperas `t` **negativo**.
:::

---

## 6. Ejemplo pr√°ctico con una variable `y` en {-1, 0, 1} (local)

Aqu√≠ usamos un ejemplo tipo ‚Äúauditor√≠a‚Äù con una variable de decisi√≥n:

- `-1`, `0`, `1` (tres resultados posibles).

```{python}
audit_like = pd.DataFrame({
    "y": [-1, 0, 0, -1, 1, 0, -1, 0, 0, 1,
          0, 0, -1, 0, 1, 0, 0, -1, 0, 0,
          1, 0, -1, 0, 0, 0, -1, 0, 0, 1]
})
audit_like["y"].value_counts()
```

### 6.1 IC 95% y 99% usando cuantiles normales

```{python}
y = audit_like["y"]
n = len(y)

promedio_y = np.mean(y)
s_y = np.std(y, ddof=1)
se_y = s_y / np.sqrt(n)

c95 = stats.norm.ppf(0.975)
c99 = stats.norm.ppf(0.995)

IC95 = (promedio_y - c95 * se_y, promedio_y + c95 * se_y)
IC99 = (promedio_y - c99 * se_y, promedio_y + c99 * se_y)

IC95, IC99
```

::: {.callout-note}
### Sintaxis clave (normal)
- `stats.norm.ppf(0.975)` ‚âà 1.96 (IC 95% bilateral).
- `stats.norm.ppf(0.995)` ‚âà 2.576 (IC 99% bilateral).
:::

---

### 6.2 Prueba t (dos colas) para `y`

```{python}
test_y = stats.ttest_1samp(y, popmean=0)
test_y.statistic, test_y.pvalue
```

---

## 7. Aplicaci√≥n con datos reales (opcional, online)

```{python}
#| eval: false
# En VSCode: pip install wooldridge
# En Colab:  !pip -q install wooldridge
import wooldridge as woo
import numpy as np
from scipy import stats

audit = woo.dataWoo("audit")
y = audit["y"]

promedio_y = np.mean(y)
n = len(y)
se_y = np.std(y, ddof=1) / np.sqrt(n)

c95 = stats.norm.ppf(0.975)
print("IC 95%:", promedio_y - c95*se_y, promedio_y + c95*se_y)

print(stats.ttest_1samp(y, popmean=0))
```

---

## Ejercicios propuestos

1) **IC 95% (t)**  
   Con `variacion`, calcula el IC 95% usando `ppf(0.975, n-1)`.

   **Respuesta esperada:** dos n√∫meros (LI, LS).

2) **t manual**  
   Calcula `t_manual = (promedio - 0) / se`.

   **Respuesta esperada:** un n√∫mero (signo depende del promedio).

3) **Valor cr√≠tico (cola izquierda)**  
   Calcula `stats.t.ppf(0.05, n-1)`.

   **Respuesta esperada:** un n√∫mero negativo.

4) **Valor p (cola izquierda)**  
   Calcula `stats.t.cdf(t_manual, n-1)`.

   **Respuesta esperada:** n√∫mero entre 0 y 1.

5) **Autom√°tico**  
   Calcula `stats.ttest_1samp(variacion, 0).statistic`.

   **Respuesta esperada:** muy cercano a `t_manual`.

6) **IC 99% (normal)**  
   Para `audit_like["y"]`, calcula IC 99% con `stats.norm.ppf(0.995)`.

   **Respuesta esperada:** intervalo m√°s ancho que el IC 95%.

---

::: {.content-visible when-format="pdf"}
## Glosario (para Colab)

- **SE**: error est√°ndar del promedio.
- **ddof=1**: ajuste muestral en desviaci√≥n est√°ndar.
- **ppf**: cuantil (inversa de CDF).
- **valor cr√≠tico**: punto de corte para decisi√≥n.
- **valor p**: probabilidad bajo H0.
:::
