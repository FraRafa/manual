---
title: "Cap√≠tulo 8 ‚Äî Python avanzado: condicionales, bucles, funciones y SymPy"
---

[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/08-python-avanzado-condicionales-bucles-funciones-sympy.ipynb){.btn .btn-success target="_blank"}

```{python}
#| include: false
# Setup interno (se ejecuta, pero no se muestra en HTML/PDF)
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

plt.rcParams["figure.figsize"] = (8, 4.5)
plt.rcParams["figure.dpi"] = 120

# SymPy es opcional: si no est√° instalado, el cap√≠tulo igual renderiza.
try:
    import sympy as sp
except Exception:
    sp = None
```

::: {.callout-note}
## Objetivos del cap√≠tulo

- Usar **condicionales** (`if/elif/else`) para tomar decisiones sin ‚Äúromper‚Äù el programa.
- Escribir **bucles** (`for` y `while`) con acumuladores y contadores, sin errores de l√≥gica.
- Crear **funciones** reutilizables con validaci√≥n de argumentos.
- (Opcional) Usar **SymPy** para resolver ecuaciones y graficar funciones impl√≠citas sin depender de ‚Äúc√°lculo manual‚Äù.
:::

::: {.column-margin}
<details>
<summary><strong>Glosario</strong></summary>

- **condicional**: bloque que se ejecuta si se cumple una condici√≥n (`if`).
- **bucle**: repite un bloque de c√≥digo (ej. `for`, `while`).
- **acumulador**: variable que ‚Äúsuma‚Äù/‚Äújunta‚Äù resultados dentro de un bucle.
- **√≠ndice**: posici√≥n dentro de una secuencia (0, 1, 2, ...).
- **return**: salida de una funci√≥n (lo que la funci√≥n ‚Äúdevuelve‚Äù).
- **argumento**: valor que le pasas a una funci√≥n (ej. `raizp(9)`).
- **SymPy**: librer√≠a para matem√°ticas simb√≥licas (resolver/derivar/ecuaciones).
- **funci√≥n impl√≠cita**: ecuaci√≥n del tipo `F(x, y) = 0` (no despejada).
</details>
:::

---

## 1. Condicionales y bucles (patrones que vas a usar siempre)

### 1.1 Bucle + condicional (ejemplo b√°sico)

```{python}
# Ejemplo b√°sico de un bucle y un condicional
i = 1
for x in [1, 7, 20, 12, 9, 17]:
    if x % 2 == 0:
        print(i, x, "es par")
    else:
        print(i, x, "es impar")
    i += 1
```

::: {.callout-note}
### Sintaxis (en simple)

- `for x in [...]`: recorre elementos de una lista (uno por uno).
- `if x % 2 == 0`: condici√≥n (aqu√≠: ‚Äú¬øx es divisible para 2?‚Äù).
- `i += 1`: abreviaci√≥n de `i = i + 1` (incrementa el contador).
:::

::: {.callout-warning}
### Error com√∫n
Olvidar `i += 1` deja el contador ‚Äúcongelado‚Äù y el resultado se repite mal.
:::

---

### 1.2 Bucle con secuencia no num√©rica y acumulador

```{python}
# Ejemplo de bucle con secuencia no num√©rica y variable que se acumula
lista = ["Econom√≠a", "Estad√≠stica", "Python", "Datos"]

acum = ""
for palabra in lista:
    acum = acum + palabra + " | "

acum
```

::: {.callout-note}
### Para qu√© sirve esto
Un acumulador es √∫til cuando:
- construyes texto,
- construyes una lista de resultados,
- sumas valores (ej. suma total, promedio, etc.).
:::

::: {.callout-tip}
### Tip
Para textos muy largos, a veces es mejor acumular en lista y al final usar `"".join(...)`.
Aqu√≠ lo hacemos simple a prop√≥sito.
:::

---

### 1.3 √çndices en un `for` (cuando necesitas posici√≥n)

```{python}
# Ejemplo de bucle donde el contador se usa como √≠ndice
x = [10, 2, 7, 15]
y = [0] * len(x)  # crea una lista de ceros del mismo tama√±o

for i in range(len(x)):
    y[i] = x[i] ** 2

x, y
```

::: {.callout-note}
### Sintaxis clave

- `range(len(x))` produce 0, 1, 2, ..., `len(x)-1`.
- `y = [0] * len(x)` reserva espacio para escribir resultados.
- `x[i]` es ‚Äúel elemento i-√©simo‚Äù (ojo: Python empieza en 0).
:::

::: {.callout-warning}
### Error com√∫n
Confundir √≠ndices: el primer elemento es `x[0]`, no `x[1]`.
:::

---

### 1.4 El mismo ejemplo usando `while`

```{python}
# Ejemplo anterior usando "while"
x = [10, 2, 7, 15]
y = [0] * len(x)

i = 0
while i < len(x):
    y[i] = x[i] ** 2
    i += 1

x, y
```

::: {.callout-note}
### Cu√°ndo usar `while`
√ösalo cuando no sabes cu√°ntas repeticiones necesitas de antemano,
y la condici√≥n ‚Äúde parada‚Äù depende de lo que ocurre dentro del bucle.
:::

::: {.callout-warning}
### Error com√∫n (grave)
Un `while` sin `i += 1` (o sin actualizar la condici√≥n) puede volverse un **bucle infinito**.
:::

---

## 2. Funciones (para no copiar/pegar c√≥digo)

Una funci√≥n te permite empaquetar un procedimiento y reutilizarlo:

- Recibe **argumentos**
- Hace un proceso
- Devuelve un resultado con `return`

### 2.1 Ejemplo: ra√≠z cuadrada solo para positivos

```{python}
# Definimos funci√≥n que obtiene la ra√≠z cuadrada pero solo de n√∫meros positivos
def raizp(x):
    if x < 0:
        return None
    return np.sqrt(x)

raizp(9), raizp(-9)
```

::: {.callout-note}
### Sintaxis clave

- `def nombre(parametro):` define una funci√≥n.
- `return ...` devuelve un resultado y termina la funci√≥n.
- `return None` es una forma simple de decir ‚Äúno hay resultado v√°lido‚Äù.
:::

::: {.callout-tip}
### Tip de calidad
En proyectos reales, muchas veces conviene lanzar un error con `raise ValueError(...)`.
Aqu√≠ usamos `None` para mantenerlo amigable para principiantes.
:::

---

### 2.2 Funci√≥n l√≥gica: ¬øes potencia de 3?

```{python}
# Definimos funci√≥n para saber si un n√∫mero n es potencia de 3
def es_potencia_de_3(n):
    if n < 1:
        return False
    while n % 3 == 0:
        n = n // 3  # divisi√≥n entera
    return n == 1

for k in [1, 3, 9, 12, 27, 28, 81]:
    print(k, es_potencia_de_3(k))
```

::: {.callout-note}
### Sintaxis clave

- `n // 3` divide y se queda con la parte entera.
- `while n % 3 == 0` sigue mientras ‚Äúsea divisible por 3‚Äù.
- al final preguntamos si qued√≥ `n == 1`.
:::

---

### 2.3 Funci√≥n aplicada: fractal tipo ‚Äútapete‚Äù (Sierpi≈Ñski) (visual)

> En este ejemplo, **n debe ser potencia de 3**.

```{python}
# Definimos funci√≥n para crear un fractal (tapete de Sierpi≈Ñski) (n debe ser potencia de 3)
def ej_fractal(n):
    if not es_potencia_de_3(n):
        raise ValueError("n debe ser potencia de 3 (ej. 3, 9, 27, 81, ...)")

    A = np.ones((n, n), dtype=int)
    step = n

    while step > 1:
        step = step // 3
        for i in range(0, n, step * 3):
            for j in range(0, n, step * 3):
                A[i + step:i + 2 * step, j + step:j + 2 * step] = 0

    plt.imshow(A, cmap="gray_r")
    plt.axis("off")
    plt.title(f"Fractal (n={n})")
    plt.show()
    plt.close()

ej_fractal(27)
```

::: {.callout-tip}
### Tips y errores comunes

- Si usas un `n` que no sea potencia de 3, este ejemplo **debe fallar**: eso es intencional (validaci√≥n).
- Si tu entorno no muestra la figura, revisa que est√©s ejecutando en un notebook (Colab/Jupyter) o en Quarto con ejecuci√≥n habilitada.
:::

---

## 3. SymPy (opcional): ecuaciones, derivadas y gr√°ficas impl√≠citas

Si SymPy no est√° disponible, el manual no se rompe: simplemente no ejecutamos esta parte.

```{python}
if sp is None:
    print("SymPy no est√° instalado en este entorno. En Colab puedes instalar con: !pip -q install sympy")
```

### 3.1 Expresiones simb√≥licas y graficar una funci√≥n

```{python}
if sp is not None:
    # Importamos m√≥dulo SymPy (Symbolic Python: biblioteca para matem√°ticas simb√≥licas)
    x = sp.Symbol("x")

    # Ejemplo: par√°bola
    f = x**2 - 4*x + 3

    # Graficar con SymPy (r√°pido)
    sp.plot(f, (x, -2, 6), title="f(x) = x^2 - 4x + 3", show=True)
```

::: {.callout-note}
### Sintaxis clave (SymPy)

- `sp.Symbol("x")` crea una variable simb√≥lica.
- `f = ...` crea una expresi√≥n simb√≥lica.
- `sp.plot(...)` grafica en un rango.
:::

---

### 3.2 Resolver un sistema de ecuaciones (dos ecuaciones)

```{python}
if sp is not None:
    x, y = sp.symbols("x y")

    eq1 = sp.Eq(x + y, 10)
    eq2 = sp.Eq(2*x - y, 3)

    sol = sp.solve([eq1, eq2], [x, y], dict=True)
    sol
```

::: {.callout-tip}
### Tip
`dict=True` te devuelve la soluci√≥n como diccionario, m√°s c√≥modo para leer y reemplazar.
:::

---

### 3.3 Graficar funciones impl√≠citas (una o varias)

A veces tienes ecuaciones del tipo:

- `F(x, y) = 0`

y quieres graficar su curva.

```{python}
if sp is not None:
    x, y = sp.symbols("x y")

    # Funci√≥n para graficar varias funciones impl√≠citas
    def plot_implicitas(ecuaciones, xlim=(-5, 5), ylim=(-5, 5), titulo="Funciones impl√≠citas"):
        p = sp.plot_implicit(ecuaciones[0], (x, xlim[0], xlim[1]), (y, ylim[0], ylim[1]),
                             show=False)
        for eq in ecuaciones[1:]:
            p2 = sp.plot_implicit(eq, (x, xlim[0], xlim[1]), (y, ylim[0], ylim[1]),
                                  show=False)
            for s in p2:
                p.append(s)
        p.title = titulo
        p.show()

    # Planeando y resolviendo un sistema de dos ecuaciones (y graficando)
    eq1 = sp.Eq(x + y - 2, 0)
    eq2 = sp.Eq(x**2 + y**2 - 4, 0)

    plot_implicitas([eq1, eq2], xlim=(-3, 3), ylim=(-3, 3), titulo="Intersecci√≥n de dos curvas")
```

::: {.callout-warning}
### Error com√∫n
En `plot_implicit` las ecuaciones deben quedar como igualdad a cero (o con `Eq(..., 0)`).
Si no, SymPy a veces interpreta mal lo que quieres graficar.
:::

---

## Ejercicios propuestos

1) **Par o impar (bucle + condicional)**  
   Crea una lista con 10 n√∫meros enteros y escribe un bucle que imprima si cada uno es par o impar.

   **Respuesta esperada:** 10 l√≠neas, cada una con ‚Äúpar‚Äù o ‚Äúimpar‚Äù.

2) **Acumulador de texto**  
   Dada una lista de palabras, construye un string final separado por comas.

   **Respuesta esperada:** un string tipo `"a, b, c, d"`.

3) **Cuadrados con √≠ndice**  
   Dada una lista `x`, crea `y` con los cuadrados, pero esta vez usando un `while`.

   **Respuesta esperada:** `y[i] == x[i]**2` para todo i.

4) **Funci√≥n de validaci√≥n**  
   Escribe una funci√≥n `solo_positivos(x)` que devuelva `x` si `x>0` y `None` si no.

   **Respuesta esperada:** `solo_positivos(3)=3` y `solo_positivos(-1)=None`.

5) **Potencia de 3**  
   Prueba tu funci√≥n `es_potencia_de_3` con los valores 1, 2, 3, 9, 18, 27.

   **Respuesta esperada:** `True` solo para 1, 3, 9, 27.

6) *(Opcional)* **SymPy: sistema**  
   Resuelve un sistema 2x2 distinto al del ejemplo y muestra la soluci√≥n.

   **Respuesta esperada:** una soluci√≥n `{x: ..., y: ...}`.

---

::: {.content-visible when-format="pdf"}
## Glosario (para Colab)

- **if/elif/else**: decisiones por condici√≥n.
- **for / while**: bucles para repetici√≥n.
- **acumulador**: variable que agrega resultados.
- **√≠ndice**: posici√≥n en una lista/array (empieza en 0).
- **return**: salida de una funci√≥n.
- **SymPy**: librer√≠a simb√≥lica (resolver/derivar/graficar).
:::
