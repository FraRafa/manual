---
title: "Cap√≠tulo 2 ‚Äî Objetos en Python (variables, listas, numpy y pandas)"
---

[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/02-objetos-en-python.ipynb){.btn .btn-success target="_blank"}

```{python}
#| include: false
# Setup interno (se ejecuta, pero no se muestra en HTML/PDF)
import sys
```

::: {.callout-note}
## Objetivos del cap√≠tulo

Al terminar este cap√≠tulo vas a poder:

- identificar tipos de datos comunes (`str`, `int`, `float`, `bool`),
- crear y manipular **listas** y **diccionarios**,
- trabajar con arreglos `numpy` (vectores y matrices) usando √≠ndices y condiciones,
- crear y explorar tablas con `pandas` (`DataFrame`) y seleccionar datos con `[]`, `.loc` y `.iloc`.
:::

---

## 1. Variables y objetos

En Python, **todo es un objeto**: n√∫meros, texto, listas, tablas, etc.  
Lo que cambia es el **tipo** (*type*), y el tipo determina qu√© operaciones puedes hacer.

::: {.column-margin}
<details>
<summary><strong>Glosario</strong></summary>

- **objeto**: cualquier ‚Äúcosa‚Äù en Python (n√∫mero, texto, lista, tabla‚Ä¶).
- **tipo (type)**: la categor√≠a de un objeto (`int`, `float`, `str`, `bool`).
- **√≠ndice (index)**: posici√≥n de un elemento. En Python empieza en `0`.
- **m√©todo**: funci√≥n ‚Äúpegada‚Äù a un objeto, por ejemplo `lista.sort()`.
- **mutabilidad**: si un objeto puede cambiar por dentro (listas s√≠; tuplas no).
- **alias**: dos nombres apuntando al mismo objeto (com√∫n con listas).
</details>
:::

### Texto, n√∫meros y booleanos

```{python}
texto = "Hola"
entero = 10
decimal = 3.14
bandera = True  # tambi√©n existe False

type(texto), type(entero), type(decimal), type(bandera)
```

**C√≥mo leer esto:**
- `str` ‚Üí texto (*string*)
- `int` ‚Üí n√∫mero entero
- `float` ‚Üí n√∫mero con decimales
- `bool` ‚Üí verdadero/falso

::: {.callout-tip}
**Tip**  
Cuando no sabes ‚Äúqu√© es‚Äù una variable, usa `type(variable)`.
:::

---

## 1.1 Listas

Una **lista** guarda varios elementos en orden.

- Se crea con corchetes: `[ ]`
- Puedes mezclar tipos, pero para empezar es mejor mantener listas ‚Äúcoherentes‚Äù (solo n√∫meros o solo texto).

```{python}
lista_texto = ["Ana", "Luis", "Mar√≠a"]
lista_numeros = [10, 20, 30, 40]
```

### Indexaci√≥n (empieza en 0)

```{python}
lista_numeros[0]   # primer elemento
```

```{python}
lista_numeros[2]   # tercer elemento
```

::: {.callout-warning}
**Error t√≠pico**  
Pedir un √≠ndice que no existe da `IndexError`.  
Ejemplo: si la lista tiene 4 elementos, el √∫ltimo √≠ndice es `3`.
:::

### Slicing (rangos)

```{python}
lista_numeros[1:4]  # del segundo al cuarto (4 no se incluye)
```

**Regla mental:** `inicio` se incluye, `fin` NO.

### Modificar un elemento

Las listas son **mutables** (se pueden cambiar por dentro).

```{python}
lista_numeros[2] = 99
lista_numeros
```

---

## 1.2 Funciones vs m√©todos

- `max(lista)` es una **funci√≥n**: vive ‚Äúpor fuera‚Äù y recibe el objeto.
- `lista.sort()` es un **m√©todo**: vive ‚Äúdentro‚Äù del objeto lista.

```{python}
max(lista_numeros)
```

```{python}
lista_numeros.sort()
lista_numeros
```

::: {.callout-tip}
**Tip**  
Si ves un punto `objeto.algo()`, casi siempre est√°s usando un **m√©todo**.
:::

---

## 1.3 Cuidado: alias al copiar listas

Este es un error muy com√∫n al empezar: `b = a` **no crea una copia**, crea un **alias**.

```{python}
a = [1, 2, 3]
b = a        # b NO es copia: es el mismo objeto
b[0] = 999

a, b
```

La forma correcta es usar `.copy()`.

```{python}
a = [1, 2, 3]
b = a.copy()
b[0] = 999

a, b
```

---

## 1.4 Diccionarios

Un **diccionario** guarda pares **clave ‚Üí valor**.

- Se crea con llaves: `{ }`
- Las claves suelen ser texto (strings).

```{python}
estudiante = {"nombre": "Juan", "nota": 14}
estudiante
```

Acceder por clave:

```{python}
estudiante["nota"]
```

Modificar / agregar claves:

```{python}
estudiante["nota"] = estudiante["nota"] + 6
estudiante["edad"] = 20
estudiante
```

---

## 2. Arreglos con numpy

`numpy` est√° optimizado para trabajar con n√∫meros en forma de **vectores** y **matrices**.

```{python}
import numpy as np
```

::: {.callout-note}
**Idea clave**  
`numpy` permite operaciones ‚Äúvectorizadas‚Äù: sumas, multiplicaciones y comparaciones que se aplican a todos los elementos sin usar bucles.
:::

### Vectores (array 1D)

```{python}
x = np.array([10, 20, 30, 40])
x
```

Indexaci√≥n:

```{python}
x[2]  # tercer elemento
```

Selecci√≥n por lista de √≠ndices:

```{python}
x[[0, 2]]  # primero y tercero
```

Selecci√≥n booleana (filtro):

```{python}
x[x > 20]
```

::: {.callout-tip}
**Tip**  
`x > 20` produce un vector de `True/False`.  
Luego `x[ ... ]` filtra usando esos `True/False`.
:::

---

### Matrices (array 2D)

```{python}
A = np.array([[1, 2, 3, 4],
              [5, 6, 7, 8],
              [9, 10, 11, 12]])
A
```

Dimensi√≥n:

```{python}
A.shape  # (filas, columnas)
```

Un elemento (fila 2, columna 3) recordando que empieza en 0:

```{python}
A[1, 2]
```

Rangos:

```{python}
A[:, 1:3]   # todas las filas, columnas 2 y 3
```

---

### Crear arrays √∫tiles

```{python}
np.linspace(0, 1, 5)   # 5 valores entre 0 y 1
```

```{python}
np.arange(0, 10)       # 0,1,2,...,9
```

```{python}
np.zeros((2, 3))
```

```{python}
np.ones((2, 3))
```

---

### Operaciones con matrices

Suma / multiplicaci√≥n elemento a elemento:

```{python}
B = np.array([[1, 1, 1],
              [2, 2, 2]])
C = np.array([[10, 10, 10],
              [20, 20, 20]])

B + C
```

```{python}
B * C  # elemento a elemento
```

Multiplicaci√≥n matricial (√°lgebra lineal):

```{python}
M = np.array([[1, 2],
              [3, 4]])
N = np.array([[10, 0],
              [0, 10]])

M @ N
```

::: {.callout-warning}
**Ojo**  
`*` NO es multiplicaci√≥n matricial en `numpy`.  
- `*` = elemento a elemento  
- `@` = multiplicaci√≥n matricial
:::

---

## 3. Tablas con pandas

`pandas` est√° pensado para trabajar con datos en tablas (`DataFrame`).

```{python}
import pandas as pd
```

### Crear un DataFrame

Usamos un ejemplo peque√±o y local (sin internet) para practicar.

```{python}
df = pd.DataFrame({
    "ventas": [100, 120, 90, 130, 110],
    "clima":  ["sol", "sol", "lluvia", "sol", "lluvia"],
    "clientes": [20, 25, 18, 30, 22]
})
df
```

Definir un √≠ndice (etiquetas de filas):

```{python}
df.index = ["d1", "d2", "d3", "d4", "d5"]
df
```

---

### Selecci√≥n de columnas y filas

**Columnas por nombre**

```{python}
df["ventas"]
```

**Varias columnas**

```{python}
df[["ventas", "clientes"]]
```

**Filas por etiqueta (con `.loc`)**

```{python}
df.loc["d2":"d4"]
```

**Filas por posici√≥n (con `.iloc`)**

```{python}
df.iloc[1:4]  # filas 2 a 4 (4 no se incluye)
```

**Una celda espec√≠fica**

```{python}
df.loc["d3", "clientes"]
```

```{python}
df.iloc[2, 2]  # fila 3, columna 3
```

::: {.callout-tip}
**Regla r√°pida**  
- `.loc` usa **etiquetas** (nombres)  
- `.iloc` usa **posiciones** (0,1,2,...)
:::

---

### Explorar r√°pidamente un DataFrame

```{python}
df.head()
```

```{python}
df.tail()
```

Versi√≥n compatible (solo columnas num√©ricas):

```{python}
df.select_dtypes(include="number").describe()
```

---

### Variables categ√≥ricas y promedios por grupo

```{python}
df["clima"] = df["clima"].astype("category")
df.dtypes
```

Promedio de ventas por clima:

```{python}
df.groupby("clima")["ventas"].mean()
```

---

### Rezagos (shift)

```{python}
df["ventas_lag1"] = df["ventas"].shift(1)
df
```

::: {.callout-tip}
**Tip**  
`shift(1)` mueve la columna hacia abajo: la primera fila queda con `NaN` porque no existe ‚Äúvalor anterior‚Äù.
:::

---

## Ejercicios propuestos

1) **Listas e √≠ndices**  
   Crea una lista con 5 n√∫meros.  
   - imprime el primero, el tercero y los √∫ltimos dos (usando slicing).

   - **Pista:** `lista[-1]` es el √∫ltimo.
   - **Respuesta esperada:** tres impresiones correctas sin `IndexError`.

2) **Alias vs copia**  
   Crea una lista `a = [1,2,3]`.  
   Haz `b = a` y cambia `b[0]`.  
   Luego repite pero usando `b = a.copy()`.

   - **Pista:** en el primer caso cambian ambos; en el segundo no.
   - **Respuesta esperada:** en el primer caso `a` cambia; en el segundo `a` se mantiene.

3) **numpy: selecci√≥n booleana**  
   Crea `x = np.array([1, 5, 10, 15, 20])` y selecciona solo los valores mayores a 10.

   - **Pista:** `x[x > 10]`
   - **Respuesta esperada:** `[15 20]`.

4) **pandas: selecci√≥n y groupby**  
   Con el `df` del cap√≠tulo:
   - selecciona solo `ventas` y `clientes`,
   - calcula el promedio de `ventas` por `clima`.

   - **Pista:** `df[["ventas","clientes"]]` y `df.groupby("clima")["ventas"].mean()`
   - **Respuesta esperada:** una tabla/serie y dos promedios (uno por categor√≠a).

---

::: {.content-visible when-format="pdf"}
## Glosario (para Colab)

- **objeto**: cualquier ‚Äúcosa‚Äù en Python (n√∫mero, texto, lista, tabla‚Ä¶).
- **tipo (type)**: la categor√≠a de un objeto (`int`, `float`, `str`, `bool`).
- **√≠ndice (index)**: posici√≥n de un elemento. En Python empieza en `0`.
- **m√©todo**: funci√≥n ‚Äúpegada‚Äù a un objeto, por ejemplo `lista.sort()`.
- **mutabilidad**: si un objeto puede cambiar por dentro (listas s√≠; tuplas no).
- **alias**: dos nombres apuntando al mismo objeto.
:::
