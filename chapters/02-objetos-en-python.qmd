---
title: "Cap√≠tulo 2 ‚Äî Objetos en Python (variables, listas, numpy y pandas)"
---

[üöÄ Abrir este cap√≠tulo en Google Colab](https://colab.research.google.com/github/FraRafa/manual/blob/main/notebooks/02-objetos-en-python.ipynb){.btn .btn-success target="_blank"}

```{python}
#| include: false
# Setup interno (se ejecuta, pero no se muestra en HTML/PDF)
import sys
```

::: {.callout-note}
## Objetivos del cap√≠tulo

Al terminar este cap√≠tulo vas a poder:

- identificar tipos de datos comunes (`str`, `int`, `float`, `bool`),
- crear y manipular **listas** y **diccionarios**,
- trabajar con arreglos `numpy` (vectores y matrices) usando √≠ndices y condiciones,
- crear y explorar tablas con `pandas` (`DataFrame`) y seleccionar datos con `[]`, `.loc` y `.iloc`.
:::

---

## 1. Variables y objetos

En Python, **todo es un objeto**. Lo que cambia es el **tipo** (*type*), y el tipo determina qu√© operaciones puedes hacer.

::: {.column-margin}
<details>
<summary><strong>Glosario</strong></summary>

- **objeto**: cualquier ‚Äúcosa‚Äù en Python (n√∫mero, texto, lista, tabla‚Ä¶).
- **tipo (type)**: la categor√≠a de un objeto (`int`, `float`, `str`, `bool`).
- **√≠ndice (index)**: posici√≥n de un elemento. En Python empieza en `0`.
- **m√©todo**: funci√≥n ‚Äúpegada‚Äù a un objeto, por ejemplo `lista.sort()`.
- **mutabilidad**: si un objeto puede cambiar por dentro (listas s√≠; tuplas no).
- **alias**: dos nombres apuntando al mismo objeto (com√∫n con listas).
</details>
:::

### Texto, n√∫meros y booleanos

```{python}
texto = "Hola"
entero = 10
decimal = 3.14
bandera = True  # tambi√©n existe False

type(texto), type(entero), type(decimal), type(bandera)
```

::: {.callout-note}
### Sintaxis clave (variables)

- `nombre = valor` guarda un valor con un nombre.
- Las comillas (`"..."` o `'...'`) indican **texto**.
- `True` y `False` son booleanos (no llevan comillas).
:::

---

## 1.1 Listas

Una **lista** guarda varios elementos en orden.

```{python}
lista_texto = ["Ana", "Luis", "Mar√≠a"]
lista_numeros = [10, 20, 30, 40]
```

::: {.callout-note}
### Sintaxis clave (listas)

- Se crean con corchetes: `[...]`
- Los elementos se separan con comas: `[10, 20, 30]`
- Una lista puede guardarse en una variable: `lista = [...]`
:::

### Indexaci√≥n (empieza en 0)

```{python}
lista_numeros[0]   # primer elemento
```

```{python}
lista_numeros[2]   # tercer elemento
```

::: {.callout-note}
### Sintaxis clave (indexaci√≥n)

- `lista[i]` devuelve el elemento en la posici√≥n `i`.
- El primer elemento es `i = 0`.
- El √∫ltimo elemento se puede pedir con `lista[-1]`.
:::

::: {.callout-warning}
**Error t√≠pico**  
Pedir un √≠ndice que no existe da `IndexError`.
:::

### Slicing (rangos)

```{python}
lista_numeros[1:4]  # del segundo al cuarto (4 no se incluye)
```

::: {.callout-note}
### Sintaxis clave (slicing)

- `lista[inicio:fin]` toma un rango.
- `inicio` se incluye y `fin` **no** se incluye.
- Ejemplo: `[1:4]` toma posiciones `1, 2, 3`.
:::

### Modificar un elemento

```{python}
lista_numeros[2] = 99
lista_numeros
```

::: {.callout-note}
### Sintaxis clave (modificar)

- `lista[i] = nuevo_valor` reemplaza el elemento en la posici√≥n `i`.
:::

---

## 1.2 Funciones vs m√©todos

```{python}
max(lista_numeros)
```

```{python}
lista_numeros.sort()
lista_numeros
```

::: {.callout-note}
### Sintaxis clave (funci√≥n vs m√©todo)

- **Funci√≥n:** `funcion(objeto)` ‚Üí ejemplo: `max(lista)`
- **M√©todo:** `objeto.metodo()` ‚Üí ejemplo: `lista.sort()`
:::

---

## 1.3 Cuidado: alias al copiar listas

```{python}
a = [1, 2, 3]
b = a        # alias (mismo objeto)
b[0] = 999

a, b
```

```{python}
a = [1, 2, 3]
b = a.copy() # copia real
b[0] = 999

a, b
```

::: {.callout-note}
### Sintaxis clave (copiar)

- `b = a` crea un **alias** (no copia).
- `b = a.copy()` crea una copia (superficial) de la lista.
:::

---

## 1.4 Diccionarios

```{python}
estudiante = {"nombre": "Juan", "nota": 14}
estudiante
```

::: {.callout-note}
### Sintaxis clave (diccionario)

- Se crea con llaves: `{...}`
- Dentro van pares `clave: valor`
- Ejemplo: `{"nombre": "Juan", "nota": 14}`
:::

Acceder por clave:

```{python}
estudiante["nota"]
```

Modificar / agregar claves:

```{python}
estudiante["nota"] = estudiante["nota"] + 6
estudiante["edad"] = 20
estudiante
```

::: {.callout-note}
### Sintaxis clave (usar diccionarios)

- `dicc["clave"]` devuelve el valor de esa clave.
- `dicc["clave"] = valor` crea o actualiza una clave.
:::

---

## 2. Arreglos con numpy

```{python}
import numpy as np
```

::: {.callout-note}
### Sintaxis clave (import)

- `import paquete` importa un paquete.
- `import paquete as alias` crea un alias para escribir menos.
- Ejemplo: `import numpy as np` ‚Üí usamos `np` en lugar de `numpy`.
:::

### Vectores (array 1D)

```{python}
x = np.array([10, 20, 30, 40])
x
```

::: {.callout-note}
### Sintaxis clave (crear array)

- `np.array([ ... ])` convierte una lista en un `array` de numpy.
- Para 1D: `np.array([1,2,3])`
:::

Indexaci√≥n y selecci√≥n:

```{python}
x[2]      # un elemento
```

```{python}
x[[0, 2]]  # varios √≠ndices
```

```{python}
x[x > 20]  # filtro booleano
```

::: {.callout-note}
### Sintaxis clave (selecci√≥n en numpy)

- `x[i]` un elemento
- `x[[i, j]]` varios √≠ndices (lista de √≠ndices)
- `x[condicion]` filtra por condici√≥n (devuelve solo los que cumplen)
:::

---

### Matrices (array 2D)

```{python}
A = np.array([[1, 2, 3, 4],
              [5, 6, 7, 8],
              [9, 10, 11, 12]])
A
```

::: {.callout-note}
### Sintaxis clave (2D)

- Para 2D usas listas dentro de listas: `[[...], [...]]`
- `A.shape` devuelve `(filas, columnas)`
- `A[fila, columna]` accede a un elemento
:::

```{python}
A.shape
```

```{python}
A[1, 2]
```

```{python}
A[:, 1:3]
```

::: {.callout-note}
### Sintaxis clave (`:` en numpy)

- `:` significa ‚Äútodo‚Äù
- `A[:, 1:3]` = todas las filas, columnas 1 a 2 (porque 3 no se incluye)
:::

---

### Operaciones con matrices

```{python}
B = np.array([[1, 1, 1],
              [2, 2, 2]])
C = np.array([[10, 10, 10],
              [20, 20, 20]])

B + C
```

```{python}
B * C
```

```{python}
M = np.array([[1, 2],
              [3, 4]])
N = np.array([[10, 0],
              [0, 10]])

M @ N
```

::: {.callout-warning}
### Sintaxis clave (`*` vs `@`)

- `*` = multiplicaci√≥n **elemento a elemento**
- `@` = multiplicaci√≥n **matricial**
:::

---

## 3. Tablas con pandas

```{python}
import pandas as pd
```

### Crear un DataFrame

```{python}
df = pd.DataFrame({
    "ventas": [100, 120, 90, 130, 110],
    "clima":  ["sol", "sol", "lluvia", "sol", "lluvia"],
    "clientes": [20, 25, 18, 30, 22]
})
df
```

::: {.callout-note}
### Sintaxis clave (DataFrame)

- `pd.DataFrame({...})` crea una tabla.
- Dentro usas un diccionario: cada clave es una **columna**.
- Las listas deben tener el mismo tama√±o (mismo n√∫mero de filas).
:::

```{python}
df.index = ["d1", "d2", "d3", "d4", "d5"]
df
```

---

### Selecci√≥n de columnas y filas

```{python}
df["ventas"]
```

```{python}
df[["ventas", "clientes"]]
```

::: {.callout-note}
### Sintaxis clave (seleccionar columnas)

- `df["col"]` una columna
- `df[["col1", "col2"]]` varias columnas (lista de nombres)
:::

```{python}
df.loc["d2":"d4"]
```

```{python}
df.iloc[1:4]
```

```{python}
df.loc["d3", "clientes"]
```

```{python}
df.iloc[2, 2]
```

::: {.callout-note}
### Sintaxis clave (`loc` vs `iloc`)

- `.loc[filas, columnas]` usa **etiquetas** (nombres)
- `.iloc[filas, columnas]` usa **posiciones** (0,1,2,...)
- Un rango `1:4` incluye 1,2,3 (4 no se incluye)
:::

---

### Explorar r√°pidamente

```{python}
df.head()
```

```{python}
df.tail()
```

```{python}
df.select_dtypes(include="number").describe()
```

::: {.callout-note}
### Sintaxis clave (resumen)

- `head()` muestra las primeras filas
- `tail()` muestra las √∫ltimas filas
- `select_dtypes(include="number")` se queda solo con columnas num√©ricas
- `describe()` resume estad√≠sticas (conteo, media, etc.)
:::

---

### Groupby y rezagos

```{python}
df["clima"] = df["clima"].astype("category")
df.dtypes
```

```{python}
df.groupby("clima")["ventas"].mean()
```

::: {.callout-note}
### Sintaxis clave (`groupby`)

- `df.groupby("col")` agrupa por una columna
- `["ventas"]` selecciona la variable a resumir
- `.mean()` calcula el promedio por grupo
:::

```{python}
df["ventas_lag1"] = df["ventas"].shift(1)
df
```

::: {.callout-note}
### Sintaxis clave (`shift`)

- `shift(1)` mueve los valores 1 fila hacia abajo
- sirve para crear **rezagos** (valor anterior)
:::

---

## Ejercicios propuestos

1) **√çndices y slicing con intenci√≥n**  
   Crea la lista `L = [2, 4, 6, 8, 10, 12]`.  
   Construye una nueva lista `R` que contenga **solo** los elementos de `L` que est√°n en posiciones pares (0, 2, 4, ...) y luego **reemplaza** el √∫ltimo elemento de `R` por `999`.

   **Respuesta esperada:** `R` debe quedar como `[2, 6, 999]`.

2) **Alias vs copia (comprobaci√≥n)**  
   Crea `a = [1, 2, 3]`. Luego crea `b = a` y `c = a.copy()`.  
   Cambia `b[0] = 100` y `c[1] = 200`. Imprime `a`, `b`, `c`.

   **Respuesta esperada:**  
   - `a` y `b` deben ser iguales y empezar con `100` (porque comparten el mismo objeto).  
   - `c` debe ser distinto (solo `c` debe tener `200` en la segunda posici√≥n).  
   Ejemplo coherente: `a=[100, 2, 3]`, `b=[100, 2, 3]`, `c=[1, 200, 3]`.

3) **Diccionario como ‚Äúregistro‚Äù**  
   Crea un diccionario `persona` con `{"nombre": "Ana", "edad": 19}`.  
   Luego actualiza `edad` sum√°ndole 1 y agrega una nueva clave `activo` con valor `True`.

   **Respuesta esperada:** `{"nombre": "Ana", "edad": 20, "activo": True}` (el orden puede variar).

4) **numpy: filtro + transformaci√≥n**  
   Crea `x = np.array([3, 6, 9, 12, 15])`.  
   Crea un nuevo array `y` con **solo** los valores de `x` que son m√∫ltiplos de 6 y luego s√∫males 1.

   **Respuesta esperada:** `y` debe ser `array([7, 13])`.

5) **numpy: diferencia entre `*` y `@`**  
   Define:
   - `M = np.array([[1, 2], [3, 4]])`
   - `N = np.array([[2, 0], [1, 2]])`  
   Calcula `M * N` y `M @ N`.

   **Respuesta esperada:**  
   - `M * N` debe ser `[[2, 0], [3, 8]]` (elemento a elemento).  
   - `M @ N` debe ser `[[4, 4], [10, 8]]` (matricial).

6) **pandas: selecci√≥n + columna nueva + resumen**  
   Con el `df` del cap√≠tulo:
   - crea una columna `ventas_por_cliente = ventas / clientes`,
   - filtra las filas donde `clima == "sol"`,
   - calcula el promedio de `ventas_por_cliente` en ese subconjunto.

   **Respuesta esperada:** un √∫nico n√∫mero (float).  
   Con los datos del cap√≠tulo debe ser aproximadamente `5.0` (puede verse como `5` o `5.0` seg√∫n formato).



::: {.content-visible when-format="pdf"}
## Glosario (para Colab)

- **objeto**: cualquier ‚Äúcosa‚Äù en Python (n√∫mero, texto, lista, tabla‚Ä¶).
- **tipo (type)**: la categor√≠a de un objeto (`int`, `float`, `str`, `bool`).
- **√≠ndice (index)**: posici√≥n de un elemento. En Python empieza en `0`.
- **m√©todo**: funci√≥n ‚Äúpegada‚Äù a un objeto, por ejemplo `lista.sort()`.
- **mutabilidad**: si un objeto puede cambiar por dentro (listas s√≠; tuplas no).
- **alias**: dos nombres apuntando al mismo objeto.
:::
